{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/dist/esm/BinaryMessageFormat.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/dist/esm/MessagePackHubProtocol.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/dist/esm/Utils.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/dist/esm/index.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/bl/bl.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/core-util-is/lib/util.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/inherits/inherits_browser.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/isarray/index.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/msgpack5/index.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/msgpack5/lib/decoder.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/msgpack5/lib/encoder.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/msgpack5/lib/streams.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/process-nextick-args/index.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/duplex-browser.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/_stream_duplex.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/_stream_passthrough.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/_stream_readable.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/_stream_transform.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/_stream_writable.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/internal/streams/BufferList.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/internal/streams/destroy.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/lib/internal/streams/stream-browser.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/readable-stream/readable-browser.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/safe-buffer/index.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr-protocol-msgpack/node_modules/util-deprecate/browser.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/AbortController.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/DefaultHttpClient.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/DefaultReconnectPolicy.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/Errors.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/HandshakeProtocol.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/HttpClient.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/HttpConnection.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/HubConnection.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/HubConnectionBuilder.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/IHubProtocol.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/ILogger.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/ITransport.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/JsonHubProtocol.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/Loggers.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/LongPollingTransport.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/NodeHttpClient.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/ServerSentEventsTransport.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/Subject.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/TextMessageFormat.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/Utils.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/WebSocketTransport.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/XhrHttpClient.js","webpack:///D:/work/AspNetCore/src/SignalR/clients/ts/signalr/dist/esm/index.js","webpack:///../node_modules/@dotnet/jsinterop/dist/Microsoft.JSInterop.js","webpack:///../node_modules/assert/assert.js","webpack:///../node_modules/base64-js/index.js","webpack:///../node_modules/buffer/index.js","webpack:///../node_modules/events/events.js","webpack:///../node_modules/ieee754/index.js","webpack:///../node_modules/inherits/inherits_browser.js","webpack:///../node_modules/isarray/index.js","webpack:///../node_modules/process/browser.js","webpack:///../node_modules/safe-buffer/index.js","webpack:///../node_modules/setimmediate/setImmediate.js","webpack:///../node_modules/string_decoder/lib/string_decoder.js","webpack:///../node_modules/timers-browserify/main.js","webpack:///../node_modules/util/support/isBufferBrowser.js","webpack:///../node_modules/util/util.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///./Boot.Server.ts","webpack:///./BootCommon.ts","webpack:///./Environment.ts","webpack:///./GlobalExports.ts","webpack:///./Platform/Circuits/AutoReconnectCircuitHandler.ts","webpack:///./Platform/Circuits/CircuitManager.ts","webpack:///./Platform/Circuits/ComponentDescriptor.ts","webpack:///./Platform/Circuits/DefaultReconnectDisplay.ts","webpack:///./Platform/Circuits/RenderQueue.ts","webpack:///./Platform/Circuits/UserSpecifiedDisplay.ts","webpack:///./Platform/Logging/ILogger.ts","webpack:///./Platform/Logging/Loggers.ts","webpack:///./Rendering/BrowserRenderer.ts","webpack:///./Rendering/ElementReferenceCapture.ts","webpack:///./Rendering/EventDelegator.ts","webpack:///./Rendering/EventForDotNet.ts","webpack:///./Rendering/LogicalElements.ts","webpack:///./Rendering/RenderBatch/OutOfProcessRenderBatch.ts","webpack:///./Rendering/RenderBatch/RenderBatch.ts","webpack:///./Rendering/RenderBatch/Utf8Decoder.ts","webpack:///./Rendering/Renderer.ts","webpack:///./Services/Http.ts","webpack:///./Services/UriHelper.ts","webpack:///util (ignored)","webpack:///util (ignored)?958f"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC8B;AAC/B,+C;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACgC;AACK;AACgD;AACzB;AACpB;AACxC;AACA;AACA;AACA;AACA,oDAAoD,2DAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,QAAQ;AACvB;AACA;AACA;AACA,+BAA+B,6CAAM,OAAO,4DAAa;AACzD;AACA;AACA;AACA,qBAAqB,0DAAU;AAC/B;AACA,uBAAuB,wEAAmB;AAC1C;AACA,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B,uBAAuB,wEAAmB;AAC1C,iBAAiB,2DAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAQ;AAC9B,wCAAwC,6CAAM;AAC9C;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B;AACA,iBAAiB,2DAAW;AAC5B;AACA;AACA;AACA,2BAA2B,wDAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAW;AAC7B;AACA;AACA;AACA;AACA,sBAAsB,qCAAQ;AAC9B,sCAAsC,2DAAW,4CAA4C;AAC7F;AACA,eAAe,wEAAmB;AAClC;AACA;AACA,sBAAsB,qCAAQ;AAC9B,sCAAsC,2DAAW,wDAAwD;AACzG;AACA,eAAe,wEAAmB;AAClC;AACA;AACA,sBAAsB,qCAAQ;AAC9B,sCAAsC,2DAAW,4CAA4C;AAC7F;AACA,eAAe,wEAAmB;AAClC;AACA;AACA,sBAAsB,qCAAQ;AAC9B;AACA;AACA;AACA;AACA,0CAA0C,2DAAW,4CAA4C;AACjG;AACA;AACA,0CAA0C,2DAAW,4CAA4C;AACjG;AACA;AACA,0CAA0C,2DAAW,4CAA4C;AACjG;AACA;AACA,eAAe,wEAAmB;AAClC;AACA;AACA,sBAAsB,qCAAQ;AAC9B,sCAAsC,2DAAW,wDAAwD;AACzG,eAAe,wEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACiC;AAClC,kD;;;;;;;;;;;;AC7OA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACO;AAC2D;AAClE,iC;;;;;;;;;;;ACNA,mBAAmB,mBAAO,CAAC,mIAAwB;AACnD,mBAAmB,mBAAO,CAAC,0CAAM;AACjC,mBAAmB,mBAAO,CAAC,2GAAa;;;AAGxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;AACH,UAAU,gBAAgB;AAC1B;AACA,GAAG;AACH;AACA,UAAU,sBAAsB;AAChC;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,QAAQ,uBAAuB;AAC/B;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;AAGD;;;;;;;;;;;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;;;;;ACJY;;AAEZ,aAAa,mBAAO,CAAC,2GAAa;AAClC,aAAa,mBAAO,CAAC,gDAAQ;AAC7B,SAAS,mBAAO,CAAC,sFAAI;AACrB,cAAc,mBAAO,CAAC,gHAAe;AACrC,kBAAkB,mBAAO,CAAC,gHAAe;AACzC,kBAAkB,mBAAO,CAAC,gHAAe;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpFA,SAAS,mBAAO,CAAC,sFAAI;AACrB,WAAW,mBAAO,CAAC,0CAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9aY;;AAEZ,aAAa,mBAAO,CAAC,2GAAa;AAClC,SAAS,mBAAO,CAAC,sFAAI;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC9TY;;AAEZ,gBAAgB,mBAAO,CAAC,8HAAiB;AACzC,eAAe,mBAAO,CAAC,gHAAU;AACjC,SAAS,mBAAO,CAAC,sFAAI;;AAErB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpFA,+CAAa;;AAEb;AACA;AACA;AACA,oBAAoB;AACpB,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;AC1CA,iBAAiB,mBAAO,CAAC,wIAAyB;;;;;;;;;;;;;ACAlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,6HAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,gHAAc;AACjC,gBAAgB,mBAAO,CAAC,gHAAU;AAClC;;AAEA,eAAe,mBAAO,CAAC,qIAAoB;AAC3C,eAAe,mBAAO,CAAC,qIAAoB;;AAE3C;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,gBAAgB,mBAAO,CAAC,uIAAqB;;AAE7C;AACA,WAAW,mBAAO,CAAC,gHAAc;AACjC,gBAAgB,mBAAO,CAAC,gHAAU;AAClC;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,E;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,6HAAsB;AACxC;;AAEA;;AAEA;AACA,cAAc,mBAAO,CAAC,mGAAS;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,mBAAO,CAAC,gDAAQ;;AAEzB;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,2JAA2B;AAChD;;AAEA;;AAEA,aAAa,mBAAO,CAAC,2GAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,gHAAc;AACjC,gBAAgB,mBAAO,CAAC,gHAAU;AAClC;;AAEA;AACA,gBAAgB,mBAAO,CAAC,aAAM;AAC9B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,2JAA+B;AACxD,kBAAkB,mBAAO,CAAC,qJAA4B;AACtD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,6EAA6E;AACtJ;;AAEA;AACA,qBAAqB,mBAAO,CAAC,iIAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,mBAAO,CAAC,6EAAiB;AACjE;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,iIAAkB;;AAE/C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,kGAAkG;AAClG,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,4FAA4F;AAC5F,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,mBAAO,CAAC,6EAAiB;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,4EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA,mDAAmD,iEAAiE;AACpH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,uCAAuC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,C;;;;;;;;;;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,iIAAkB;;AAEvC;AACA,WAAW,mBAAO,CAAC,gHAAc;AACjC,gBAAgB,mBAAO,CAAC,gHAAU;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,C;;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,6HAAsB;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,gHAAc;AACjC,gBAAgB,mBAAO,CAAC,gHAAU;AAClC;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,mHAAgB;AACrC;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,2JAA2B;AAChD;;AAEA;;AAEA,aAAa,mBAAO,CAAC,2GAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAO,CAAC,qJAA4B;;AAEtD;;AAEA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,iIAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,iIAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;AC9qBa;;AAEb,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,aAAa,mBAAO,CAAC,2GAAa;AAClC,WAAW,mBAAO,CAAC,aAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,C;;;;;;;;;;;;AC9Ea;;AAEb;;AAEA,UAAU,mBAAO,CAAC,6HAAsB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;;ACzEA,iBAAiB,mBAAO,CAAC,gDAAQ;;;;;;;;;;;;ACAjC,2BAA2B,mBAAO,CAAC,4IAA2B;AAC9D;AACA;AACA,mBAAmB,mBAAO,CAAC,4IAA2B;AACtD,iBAAiB,mBAAO,CAAC,wIAAyB;AAClD,oBAAoB,mBAAO,CAAC,8IAA4B;AACxD,sBAAsB,mBAAO,CAAC,kJAA8B;;;;;;;;;;;;ACN5D;AACA,aAAa,mBAAO,CAAC,+CAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AAC0B;AAC3B,2C;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACqC;AACI;AACQ;AACF;AAChD,+BAA+B,iCAAiC;AAChE;AACA;AACA,uCAAuC,wCAAwC,sBAAsB,8BAA8B;AACnI;AACA;AACA;AACA,mCAAmC,4DAAa;AAChD;AACA;AACA,mCAAmC,8DAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACiB;AAC7B,6C;;;;;;;;;;;;AClDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACiC;AAClC,kD;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,sCAAsC,gCAAgC;AACtE;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,sCAAsC,sCAAsC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,sCAAsC,qCAAqC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB,kC;;;;;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AACA;AACwD;AAChB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAa;AACzB;AACA;AACA,oDAAoD,oEAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oEAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B,6C;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AACA;AACA,gBAAgB,SAAI,IAAI,SAAI;AAC5B,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY,0BAA0B;AAC1E;AACA;AACA,oCAAoC,YAAY,2BAA2B;AAC3E;AACA;AACA,oCAAoC,YAAY,6BAA6B;AAC7E;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB,sC;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACwD;AACnB;AAC4B;AACH;AACU;AAClB;AACI;AAC1D;AACA;AACA;AACA,IAAI,+CAAQ,WAAW,UAAc;AACrC;AACA;AACA,sBAAsB,KAAyC,GAAG,OAAuB,GAAG,SAAO;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA,QAAQ,0CAAG;AACX,sBAAsB,2DAAY;AAClC;AACA;AACA;AACA,aAAa,+CAAQ;AACrB;AACA;AACA,iBAAiB,+CAAQ;AACzB;AACA;AACA;AACA;AACA,aAAa,+CAAQ;AACrB;AACA;AACA,iBAAiB,+CAAQ;AACzB;AACA;AACA;AACA;AACA,oDAAoD,oEAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,0DAAc;AACzE,wBAAwB,0CAAG,sBAAsB,0DAAc;AAC/D,wCAAwC,iDAAQ,uDAAuD,0DAAc;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6DAAiB;AAC1E;AACA,iEAAiE,6DAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,sBAAsB;AAC3G;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0EAAoB;AAC1E;AACA;AACA;AACA,+DAA+D,gCAAgC;AAC/F;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,iBAAiB,6DAAiB;AAClC;AACA;AACA;AACA,2BAA2B,sEAAkB;AAC7C,iBAAiB,6DAAiB;AAClC;AACA;AACA;AACA,2BAA2B,oFAAyB;AACpD,iBAAiB,6DAAiB;AAClC,2BAA2B,0EAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAiB;AACzC;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA,iFAAiF,QAAQ,0DAAc,IAAI,EAAE;AAC7G;AACA,uCAAuC,6DAAiB;AACxD,uCAAuC,6DAAiB;AACxD,wCAAwC,iDAAQ,iCAAiC,6DAAiB;AAClG,+CAA+C,6DAAiB;AAChE;AACA;AACA,wCAAwC,iDAAQ,kCAAkC,6DAAiB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iDAAQ,iCAAiC,6DAAiB,gFAAgF,0DAAc;AAC5L,2CAA2C,6DAAiB,sCAAsC,0DAAc;AAChH;AACA;AACA;AACA,gCAAgC,iDAAQ,iCAAiC,6DAAiB;AAC1F,uCAAuC,6DAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+CAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK,EAAE,EAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,yDAAyD,qBAAqB,EAAE,0BAA0B,cAAc,EAAE;AAC1H;AACA;AACA,uDAAuD,4BAA4B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC6B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,0C;;;;;;;;;;;;ACtqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACwD;AACX;AACR;AACD;AACN;AAC9B;AACA;AACA,wCAAwC,oBAAoB;AACrD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA,QAAQ,0CAAG;AACX,QAAQ,0CAAG;AACX,QAAQ,0CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oEAAiB;AACtD,qDAAqD,wCAAwC;AAC7F,oDAAoD,sCAAsC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO,yDAAW,OAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA,yBAAyB,yDAAW;AACpC;AACA;AACA,yBAAyB,yDAAW;AACpC,yBAAyB,yDAAW;AACpC;AACA;AACA,iDAAiD,yDAAW;AAC5D;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAW;AACpC;AACA;AACA,yBAAyB,yDAAW;AACpC,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS,EAAE,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,yDAAyD,8BAA8B,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oDAAoD,EAAE;AACpG;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gCAAgC,EAAE;AAC7F;AACA;AACA,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA,iFAAiF,gCAAgC,EAAE;AACnH;AACA;AACA,gDAAgD,iDAAQ;AACxD;AACA;AACA;AACA,gDAAgD,iDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA,gFAAgF,wDAAwD,EAAE;AAC1I;AACA;AACA,gDAAgD,iDAAQ,kGAAkG;AAC1J;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,wEAAwE,EAAE;AAC5I,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iFAAiF,EAAE;AACrJ,iBAAiB;AACjB;AACA,kEAAkE,8EAA8E,EAAE;AAClJ,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B;AACA;AACA;AACA,CAAC;AACwB;AACzB,yC;;;;;;;;;;;;AC54BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,gBAAgB,SAAI,IAAI,SAAI;AAC5B,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACkE;AAChB;AACF;AACX;AACe;AACb;AACM;AAC7C;AACA;AACA,WAAW,iDAAQ;AACnB,WAAW,iDAAQ;AACnB,UAAU,iDAAQ;AAClB,iBAAiB,iDAAQ;AACzB,UAAU,iDAAQ;AAClB,aAAa,iDAAQ;AACrB,WAAW,iDAAQ;AACnB,cAAc,iDAAQ;AACtB,UAAU,iDAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oCAAoC;AACnE;AACA;AACA;AACA;AACA,QAAQ,0CAAG;AACX;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAa;AAC3C;AACA;AACA,8BAA8B,oDAAa;AAC3C;AACA;AACA;AACA;AACA,QAAQ,0CAAG;AACX;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,oDAAoD,+BAA+B,oCAAoC;AACvH;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA,eAAe,aAAa,eAAe,mCAAmC;AAC9E;AACA;AACA,QAAQ,0CAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8EAAsB;AAC7D;AACA;AACA,uCAAuC,8EAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA,iBAAiB,cAAc,iBAAiB,oCAAoC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAc;AAC3C,eAAe,4DAAa,mCAAmC,mDAAU,gCAAgC,gEAAe;AACxH;AACA;AACA,CAAC;AAC+B;AAChC;AACA;AACA;AACA,gD;;;;;;;;;;;;AC1HA;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA,2EAA2E,wCAAwC;AACnH;AACA,0EAA0E,wCAAwC;AAClH;AACA,0EAA0E,wCAAwC;AAClH;AACA,iFAAiF,8CAA8C;AAC/H;AACA,iFAAiF,8CAA8C;AAC/H;AACA,oEAAoE,kCAAkC;AACtG;AACA,qEAAqE,mCAAmC;AACxG;AACA,CAAC,kCAAkC;AACnC,wC;;;;;;;;;;;;ACpBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B,mC;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC,sC;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAC6C;AACR;AACS;AACP;AACiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAc;AAC5C;AACA,6BAA6B,iCAAiC;AAC9D;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAU;AAC/B;AACA;AACA,uBAAuB,oEAAiB;AACxC;AACA,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAW;AAChC;AACA;AACA,qBAAqB,yDAAW;AAChC;AACA;AACA,qBAAqB,yDAAW;AAChC;AACA;AACA,qBAAqB,yDAAW;AAChC;AACA;AACA,qBAAqB,yDAAW;AAChC;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA,eAAe,oEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC0B;AAC3B,2C;;;;;;;;;;;;ACzGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iCAAiC;AACxE;AACA;AACA,CAAC;AACqB;AACtB,mC;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACoD;AACD;AACd;AACS;AACY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAAG;AAC3B,wBAAwB,0CAAG;AAC3B,wBAAwB,0CAAG,sBAAsB,0DAAc;AAC/D;AACA,wCAAwC,iDAAQ;AAChD;AACA,+CAA+C,0DAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,+CAA+C,0DAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA,kDAAkD,iDAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA,kDAAkD,iDAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,gDAAgD,iDAAQ,oDAAoD,4DAAa;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iDAAQ;AACpD;AACA;AACA,+CAA+C,oDAAY;AAC3D;AACA,gDAAgD,iDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAW;AACjD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAQ;AACpC;AACA;AACA;AACA;AACA,CAAC;AAC+B;AAChC,gD;;;;;;;;;;;;AC1RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,gBAAgB,SAAI,IAAI,SAAI;AAC5B,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AAC+D;AACP;AACnB;AACG;AACxC;AACA;AACA;AACA;AACA,sBAAsB,KAAyC,GAAG,OAAuB,GAAG,SAAO;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yCAAyC,iDAAQ;AACjD,mCAAmC,oDAAY;AAC/C;AACA,qCAAqC,iDAAQ;AAC7C;AACA;AACA;AACA;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA,+BAA+B,iDAAS;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,sDAAU;AACc;AAC1B,0C;;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACqC;AACS;AACsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAAG;AAC3B,wBAAwB,0CAAG;AAC3B,wBAAwB,0CAAG,sBAAsB,0DAAc;AAC/D,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0DAAc;AACjE;AACA;AACA;AACA;AACA,gCAAgC,+CAAQ,cAAc,+CAAQ;AAC9D,qFAAqF,wBAAwB;AAC7G;AACA;AACA;AACA;AACA,qFAAqF,kCAAkC,kBAAkB,EAAE;AAC3I;AACA;AACA;AACA;AACA;AACA,6DAA6D,iDAAQ,4CAA4C,4DAAa;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iDAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0DAAW;AACjD,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoC;AACrC,qD;;;;;;;;;;;;ACvJA;AAAA;AAAA;AAAA;AACA;AAC8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAmB;AACtC;AACA;AACA,CAAC;AACkB;AACnB,mC;;;;;;;;;;;;ACrCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B,6C;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACqC;AACE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACmB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,+BAA+B,iDAAQ;AACvC;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA,iCAAiC,iDAAQ;AACzC;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,EAAE;AAChE;AACA;AACA;AACA,CAAC;AAC8B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAQ;AAC7B,qBAAqB,iDAAQ;AAC7B,qFAAqF,iDAAQ;AAC7F;AACA,qBAAqB,iDAAQ;AAC7B,oFAAoF,iDAAQ;AAC5F;AACA,qBAAqB,iDAAQ;AAC7B,oFAAoF,iDAAQ;AAC5F;AACA;AACA;AACA,mFAAmF,iDAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA,CAAC;AACwB;AACzB,iC;;;;;;;;;;;;ACvNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,mBAAmB,SAAI,IAAI,SAAI;AAC/B,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;AACqC;AACS;AACS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAAG;AAC3B,wBAAwB,0CAAG;AAC3B,wBAAwB,0CAAG,sBAAsB,0DAAc;AAC/D,wCAAwC,iDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAQ;AACxC;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,mDAAmD,0DAAc;AACjE;AACA;AACA;AACA;AACA,iDAAiD,iDAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iDAAQ,mDAAmD,4DAAa;AACzH;AACA;AACA;AACA;AACA,kEAAkE,2BAA2B;AAC7F,yBAAyB;AACzB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,4BAA4B,iDAAQ,kDAAkD,4DAAa;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,oDAAoD;AACpD,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC6B;AAC9B,8C;;;;;;;;;;;;ACxJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AAC8D;AACP;AACnB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAY;AAC5C;AACA;AACA,+BAA+B,iDAAS;AACxC;AACA;AACA;AACA,iCAAiC,iDAAQ;AACzC,2BAA2B,iDAAS;AACpC;AACA;AACA,iCAAiC,iDAAQ;AACzC,2BAA2B,oDAAY;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC,CAAC,sDAAU;AACa;AACzB,yC;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACwD;AACP;AACA;AACY;AACN;AACjB;AACR;AAC4B;AAC1B;AACa;AAChB;AACpC,iC;;;;;;;;;;;;AChBa;AACb;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gDAAgD,gLAAgL,EAAE,oBAAoB,gLAAgL,EAAE;AACxa;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,kCAAkC,EAAE;AAC5G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6BAA6B,EAAE;AAC3E;AACA;AACA,oBAAoB;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,wBAAwB;AACzB,+C;;;;;;;;;;;;AC9OA,8CAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,2CAAO;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B;AAC9B;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,oBAAoB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzeY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,qDAAW;AAChC,cAAc,mBAAO,CAAC,iDAAS;AAC/B,cAAc,mBAAO,CAAC,iDAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;AC5vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;;;;;;;;;;;AC/bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;;;;ACJA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;AACA,aAAa,mBAAO,CAAC,+CAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;;ACzLD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,yDAAa;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;ACvSA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mBAAO,CAAC,kEAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,2EAAoB;;AAE/C;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,mBAAmB,mBAAO,CAAC,8DAAU;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;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","file":"blazor.server.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./Boot.Server.ts\");\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// Not exported from index.\r\nvar BinaryMessageFormat = /** @class */ (function () {\r\n    function BinaryMessageFormat() {\r\n    }\r\n    // The length prefix of binary messages is encoded as VarInt. Read the comment in\r\n    // the BinaryMessageParser.TryParseMessage for details.\r\n    BinaryMessageFormat.write = function (output) {\r\n        // msgpack5 uses returns Buffer instead of Uint8Array on IE10 and some other browser\r\n        //  in which case .byteLength does will be undefined\r\n        var size = output.byteLength || output.length;\r\n        var lenBuffer = [];\r\n        do {\r\n            var sizePart = size & 0x7f;\r\n            size = size >> 7;\r\n            if (size > 0) {\r\n                sizePart |= 0x80;\r\n            }\r\n            lenBuffer.push(sizePart);\r\n        } while (size > 0);\r\n        // msgpack5 uses returns Buffer instead of Uint8Array on IE10 and some other browser\r\n        //  in which case .byteLength does will be undefined\r\n        size = output.byteLength || output.length;\r\n        var buffer = new Uint8Array(lenBuffer.length + size);\r\n        buffer.set(lenBuffer, 0);\r\n        buffer.set(output, lenBuffer.length);\r\n        return buffer.buffer;\r\n    };\r\n    BinaryMessageFormat.parse = function (input) {\r\n        var result = [];\r\n        var uint8Array = new Uint8Array(input);\r\n        var maxLengthPrefixSize = 5;\r\n        var numBitsToShift = [0, 7, 14, 21, 28];\r\n        for (var offset = 0; offset < input.byteLength;) {\r\n            var numBytes = 0;\r\n            var size = 0;\r\n            var byteRead = void 0;\r\n            do {\r\n                byteRead = uint8Array[offset + numBytes];\r\n                size = size | ((byteRead & 0x7f) << (numBitsToShift[numBytes]));\r\n                numBytes++;\r\n            } while (numBytes < Math.min(maxLengthPrefixSize, input.byteLength - offset) && (byteRead & 0x80) !== 0);\r\n            if ((byteRead & 0x80) !== 0 && numBytes < maxLengthPrefixSize) {\r\n                throw new Error(\"Cannot read message size.\");\r\n            }\r\n            if (numBytes === maxLengthPrefixSize && byteRead > 7) {\r\n                throw new Error(\"Messages bigger than 2GB are not supported.\");\r\n            }\r\n            if (uint8Array.byteLength >= (offset + numBytes + size)) {\r\n                // IE does not support .slice() so use subarray\r\n                result.push(uint8Array.slice\r\n                    ? uint8Array.slice(offset + numBytes, offset + numBytes + size)\r\n                    : uint8Array.subarray(offset + numBytes, offset + numBytes + size));\r\n            }\r\n            else {\r\n                throw new Error(\"Incomplete message.\");\r\n            }\r\n            offset = offset + numBytes + size;\r\n        }\r\n        return result;\r\n    };\r\n    return BinaryMessageFormat;\r\n}());\r\nexport { BinaryMessageFormat };\r\n//# sourceMappingURL=BinaryMessageFormat.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nimport { Buffer } from \"buffer\";\r\nimport * as msgpack5 from \"msgpack5\";\r\nimport { LogLevel, MessageType, NullLogger, TransferFormat, } from \"@aspnet/signalr\";\r\nimport { BinaryMessageFormat } from \"./BinaryMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n// TypeDoc's @inheritDoc and @link don't work across modules :(\r\n// constant encoding of the ping message\r\n// see: https://github.com/aspnet/SignalR/blob/dev/specs/HubProtocol.md#ping-message-encoding-1\r\n// Don't use Uint8Array.from as IE does not support it\r\nvar SERIALIZED_PING_MESSAGE = new Uint8Array([0x91, MessageType.Ping]);\r\n/** Implements the MessagePack Hub Protocol */\r\nvar MessagePackHubProtocol = /** @class */ (function () {\r\n    function MessagePackHubProtocol() {\r\n        /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n        this.name = \"messagepack\";\r\n        /** The version of the protocol. */\r\n        this.version = 1;\r\n        /** The TransferFormat of the protocol. */\r\n        this.transferFormat = TransferFormat.Binary;\r\n        this.errorResult = 1;\r\n        this.voidResult = 2;\r\n        this.nonVoidResult = 3;\r\n    }\r\n    /** Creates an array of HubMessage objects from the specified serialized representation.\r\n     *\r\n     * @param {ArrayBuffer | Buffer} input An ArrayBuffer or Buffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    MessagePackHubProtocol.prototype.parseMessages = function (input, logger) {\r\n        // The interface does allow \"string\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (!(input instanceof Buffer) && !(isArrayBuffer(input))) {\r\n            throw new Error(\"Invalid input for MessagePack hub protocol. Expected an ArrayBuffer or Buffer.\");\r\n        }\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n        var messages = BinaryMessageFormat.parse(input);\r\n        var hubMessages = [];\r\n        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n            var message = messages_1[_i];\r\n            var parsedMessage = this.parseMessage(message, logger);\r\n            // Can be null for an unknown message. Unknown message is logged in parseMessage\r\n            if (parsedMessage) {\r\n                hubMessages.push(parsedMessage);\r\n            }\r\n        }\r\n        return hubMessages;\r\n    };\r\n    /** Writes the specified HubMessage to an ArrayBuffer and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {ArrayBuffer} An ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    MessagePackHubProtocol.prototype.writeMessage = function (message) {\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n                return this.writeInvocation(message);\r\n            case MessageType.StreamInvocation:\r\n                return this.writeStreamInvocation(message);\r\n            case MessageType.StreamItem:\r\n                return this.writeStreamItem(message);\r\n            case MessageType.Completion:\r\n                return this.writeCompletion(message);\r\n            case MessageType.Ping:\r\n                return BinaryMessageFormat.write(SERIALIZED_PING_MESSAGE);\r\n            case MessageType.CancelInvocation:\r\n                return this.writeCancelInvocation(message);\r\n            default:\r\n                throw new Error(\"Invalid message type.\");\r\n        }\r\n    };\r\n    MessagePackHubProtocol.prototype.parseMessage = function (input, logger) {\r\n        if (input.length === 0) {\r\n            throw new Error(\"Invalid payload.\");\r\n        }\r\n        var msgpack = msgpack5();\r\n        var properties = msgpack.decode(Buffer.from(input));\r\n        if (properties.length === 0 || !(properties instanceof Array)) {\r\n            throw new Error(\"Invalid payload.\");\r\n        }\r\n        var messageType = properties[0];\r\n        switch (messageType) {\r\n            case MessageType.Invocation:\r\n                return this.createInvocationMessage(this.readHeaders(properties), properties);\r\n            case MessageType.StreamItem:\r\n                return this.createStreamItemMessage(this.readHeaders(properties), properties);\r\n            case MessageType.Completion:\r\n                return this.createCompletionMessage(this.readHeaders(properties), properties);\r\n            case MessageType.Ping:\r\n                return this.createPingMessage(properties);\r\n            case MessageType.Close:\r\n                return this.createCloseMessage(properties);\r\n            default:\r\n                // Future protocol changes can add message types, old clients can ignore them\r\n                logger.log(LogLevel.Information, \"Unknown message type '\" + messageType + \"' ignored.\");\r\n                return null;\r\n        }\r\n    };\r\n    MessagePackHubProtocol.prototype.createCloseMessage = function (properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 2) {\r\n            throw new Error(\"Invalid payload for Close message.\");\r\n        }\r\n        return {\r\n            // Close messages have no headers.\r\n            error: properties[1],\r\n            type: MessageType.Close,\r\n        };\r\n    };\r\n    MessagePackHubProtocol.prototype.createPingMessage = function (properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 1) {\r\n            throw new Error(\"Invalid payload for Ping message.\");\r\n        }\r\n        return {\r\n            // Ping messages have no headers.\r\n            type: MessageType.Ping,\r\n        };\r\n    };\r\n    MessagePackHubProtocol.prototype.createInvocationMessage = function (headers, properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 5) {\r\n            throw new Error(\"Invalid payload for Invocation message.\");\r\n        }\r\n        var invocationId = properties[2];\r\n        if (invocationId) {\r\n            return {\r\n                arguments: properties[4],\r\n                headers: headers,\r\n                invocationId: invocationId,\r\n                streamIds: [],\r\n                target: properties[3],\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                arguments: properties[4],\r\n                headers: headers,\r\n                streamIds: [],\r\n                target: properties[3],\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n    };\r\n    MessagePackHubProtocol.prototype.createStreamItemMessage = function (headers, properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 4) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n        return {\r\n            headers: headers,\r\n            invocationId: properties[2],\r\n            item: properties[3],\r\n            type: MessageType.StreamItem,\r\n        };\r\n    };\r\n    MessagePackHubProtocol.prototype.createCompletionMessage = function (headers, properties) {\r\n        // check minimum length to allow protocol to add items to the end of objects in future releases\r\n        if (properties.length < 4) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        var resultKind = properties[3];\r\n        if (resultKind !== this.voidResult && properties.length < 5) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        var error;\r\n        var result;\r\n        switch (resultKind) {\r\n            case this.errorResult:\r\n                error = properties[4];\r\n                break;\r\n            case this.nonVoidResult:\r\n                result = properties[4];\r\n                break;\r\n        }\r\n        var completionMessage = {\r\n            error: error,\r\n            headers: headers,\r\n            invocationId: properties[2],\r\n            result: result,\r\n            type: MessageType.Completion,\r\n        };\r\n        return completionMessage;\r\n    };\r\n    MessagePackHubProtocol.prototype.writeInvocation = function (invocationMessage) {\r\n        var msgpack = msgpack5();\r\n        var payload = msgpack.encode([MessageType.Invocation, invocationMessage.headers || {}, invocationMessage.invocationId || null,\r\n            invocationMessage.target, invocationMessage.arguments, invocationMessage.streamIds]);\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    };\r\n    MessagePackHubProtocol.prototype.writeStreamInvocation = function (streamInvocationMessage) {\r\n        var msgpack = msgpack5();\r\n        var payload = msgpack.encode([MessageType.StreamInvocation, streamInvocationMessage.headers || {}, streamInvocationMessage.invocationId,\r\n            streamInvocationMessage.target, streamInvocationMessage.arguments, streamInvocationMessage.streamIds]);\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    };\r\n    MessagePackHubProtocol.prototype.writeStreamItem = function (streamItemMessage) {\r\n        var msgpack = msgpack5();\r\n        var payload = msgpack.encode([MessageType.StreamItem, streamItemMessage.headers || {}, streamItemMessage.invocationId,\r\n            streamItemMessage.item]);\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    };\r\n    MessagePackHubProtocol.prototype.writeCompletion = function (completionMessage) {\r\n        var msgpack = msgpack5();\r\n        var resultKind = completionMessage.error ? this.errorResult : completionMessage.result ? this.nonVoidResult : this.voidResult;\r\n        var payload;\r\n        switch (resultKind) {\r\n            case this.errorResult:\r\n                payload = msgpack.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.error]);\r\n                break;\r\n            case this.voidResult:\r\n                payload = msgpack.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind]);\r\n                break;\r\n            case this.nonVoidResult:\r\n                payload = msgpack.encode([MessageType.Completion, completionMessage.headers || {}, completionMessage.invocationId, resultKind, completionMessage.result]);\r\n                break;\r\n        }\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    };\r\n    MessagePackHubProtocol.prototype.writeCancelInvocation = function (cancelInvocationMessage) {\r\n        var msgpack = msgpack5();\r\n        var payload = msgpack.encode([MessageType.CancelInvocation, cancelInvocationMessage.headers || {}, cancelInvocationMessage.invocationId]);\r\n        return BinaryMessageFormat.write(payload.slice());\r\n    };\r\n    MessagePackHubProtocol.prototype.readHeaders = function (properties) {\r\n        var headers = properties[1];\r\n        if (typeof headers !== \"object\") {\r\n            throw new Error(\"Invalid headers.\");\r\n        }\r\n        return headers;\r\n    };\r\n    return MessagePackHubProtocol;\r\n}());\r\nexport { MessagePackHubProtocol };\r\n//# sourceMappingURL=MessagePackHubProtocol.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// Copied from signalr/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val) {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n//# sourceMappingURL=Utils.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR Message Pack protocol library. */\r\nexport var VERSION = \"0.0.0-DEV_BUILD\";\r\nexport { MessagePackHubProtocol } from \"./MessagePackHubProtocol\";\r\n//# sourceMappingURL=index.js.map","var DuplexStream = require('readable-stream/duplex')\n  , util         = require('util')\n  , Buffer       = require('safe-buffer').Buffer\n\n\nfunction BufferList (callback) {\n  if (!(this instanceof BufferList))\n    return new BufferList(callback)\n\n  this._bufs  = []\n  this.length = 0\n\n  if (typeof callback == 'function') {\n    this._callback = callback\n\n    var piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n  } else {\n    this.append(callback)\n  }\n\n  DuplexStream.call(this)\n}\n\n\nutil.inherits(BufferList, DuplexStream)\n\n\nBufferList.prototype._offset = function _offset (offset) {\n  var tot = 0, i = 0, _t\n  if (offset === 0) return [ 0, 0 ]\n  for (; i < this._bufs.length; i++) {\n    _t = tot + this._bufs[i].length\n    if (offset < _t || i == this._bufs.length - 1)\n      return [ i, offset - tot ]\n    tot = _t\n  }\n}\n\n\nBufferList.prototype.append = function append (buf) {\n  var i = 0\n\n  if (Buffer.isBuffer(buf)) {\n    this._appendBuffer(buf);\n  } else if (Array.isArray(buf)) {\n    for (; i < buf.length; i++)\n      this.append(buf[i])\n  } else if (buf instanceof BufferList) {\n    // unwrap argument into individual BufferLists\n    for (; i < buf._bufs.length; i++)\n      this.append(buf._bufs[i])\n  } else if (buf != null) {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf == 'number')\n      buf = buf.toString()\n\n    this._appendBuffer(Buffer.from(buf));\n  }\n\n  return this\n}\n\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\n\nBufferList.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback == 'function')\n    callback()\n}\n\n\nBufferList.prototype._read = function _read (size) {\n  if (!this.length)\n    return this.push(null)\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\n\nBufferList.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\n\nBufferList.prototype.get = function get (index) {\n  return this.slice(index, index + 1)[0]\n}\n\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start == 'number' && start < 0)\n    start += this.length\n  if (typeof end == 'number' && end < 0)\n    end += this.length\n  return this.copy(null, 0, start, end)\n}\n\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart != 'number' || srcStart < 0)\n    srcStart = 0\n  if (typeof srcEnd != 'number' || srcEnd > this.length)\n    srcEnd = this.length\n  if (srcStart >= this.length)\n    return dst || Buffer.alloc(0)\n  if (srcEnd <= 0)\n    return dst || Buffer.alloc(0)\n\n  var copy   = !!dst\n    , off    = this._offset(srcStart)\n    , len    = srcEnd - srcStart\n    , bytes  = len\n    , bufoff = (copy && dstStart) || 0\n    , start  = off[1]\n    , l\n    , i\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd == this.length) {\n    if (!copy) { // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n\n  for (i = off[0]; i < this._bufs.length; i++) {\n    l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      break\n    }\n\n    bufoff += l\n    bytes -= l\n\n    if (start)\n      start = 0\n  }\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = end || this.length\n\n  if (start < 0)\n    start += this.length\n  if (end < 0)\n    end += this.length\n\n  var startOffset = this._offset(start)\n    , endOffset = this._offset(end)\n    , buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] == 0)\n    buffers.pop()\n  else\n    buffers[buffers.length-1] = buffers[buffers.length-1].slice(0, endOffset[1])\n\n  if (startOffset[1] != 0)\n    buffers[0] = buffers[0].slice(startOffset[1])\n\n  return new BufferList(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n  return this\n}\n\n\nBufferList.prototype.duplicate = function duplicate () {\n  var i = 0\n    , copy = new BufferList()\n\n  for (; i < this._bufs.length; i++)\n    copy.append(this._bufs[i])\n\n  return copy\n}\n\n\nBufferList.prototype.destroy = function destroy () {\n  this._bufs.length = 0\n  this.length = 0\n  this.push(null)\n}\n\n\n;(function () {\n  var methods = {\n      'readDoubleBE' : 8\n    , 'readDoubleLE' : 8\n    , 'readFloatBE'  : 4\n    , 'readFloatLE'  : 4\n    , 'readInt32BE'  : 4\n    , 'readInt32LE'  : 4\n    , 'readUInt32BE' : 4\n    , 'readUInt32LE' : 4\n    , 'readInt16BE'  : 2\n    , 'readInt16LE'  : 2\n    , 'readUInt16BE' : 2\n    , 'readUInt16LE' : 2\n    , 'readInt8'     : 1\n    , 'readUInt8'    : 1\n  }\n\n  for (var m in methods) {\n    (function (m) {\n      BufferList.prototype[m] = function (offset) {\n        return this.slice(offset, offset + methods[m])[m](0)\n      }\n    }(m))\n  }\n}())\n\n\nmodule.exports = BufferList\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar assert = require('assert')\nvar bl = require('bl')\nvar streams = require('./lib/streams')\nvar buildDecode = require('./lib/decoder')\nvar buildEncode = require('./lib/encoder')\n\nfunction msgpack (options) {\n  var encodingTypes = []\n  var decodingTypes = []\n\n  options = options || {\n    forceFloat64: false,\n    compatibilityMode: false,\n    disableTimestampEncoding: false // if true, skips encoding Dates using the msgpack timestamp ext format (-1)\n  }\n\n  function registerEncoder (check, encode) {\n    assert(check, 'must have an encode function')\n    assert(encode, 'must have an encode function')\n\n    encodingTypes.push({\n      check: check, encode: encode\n    })\n\n    return this\n  }\n\n  function registerDecoder (type, decode) {\n    assert(type >= 0, 'must have a non-negative type')\n    assert(decode, 'must have a decode function')\n\n    decodingTypes.push({\n      type: type, decode: decode\n    })\n\n    return this\n  }\n\n  function register (type, constructor, encode, decode) {\n    assert(constructor, 'must have a constructor')\n    assert(encode, 'must have an encode function')\n    assert(type >= 0, 'must have a non-negative type')\n    assert(decode, 'must have a decode function')\n\n    function check (obj) {\n      return (obj instanceof constructor)\n    }\n\n    function reEncode (obj) {\n      var buf = bl()\n      var header = Buffer.allocUnsafe(1)\n\n      header.writeInt8(type, 0)\n\n      buf.append(header)\n      buf.append(encode(obj))\n\n      return buf\n    }\n\n    this.registerEncoder(check, reEncode)\n    this.registerDecoder(type, decode)\n\n    return this\n  }\n\n  return {\n    encode: buildEncode(encodingTypes, options.forceFloat64, options.compatibilityMode, options.disableTimestampEncoding),\n    decode: buildDecode(decodingTypes),\n    register: register,\n    registerEncoder: registerEncoder,\n    registerDecoder: registerDecoder,\n    encoder: streams.encoder,\n    decoder: streams.decoder,\n    // needed for levelup support\n    buffer: true,\n    type: 'msgpack5',\n    IncompleteBufferError: buildDecode.IncompleteBufferError\n  }\n}\n\nmodule.exports = msgpack\n","var bl = require('bl')\nvar util = require('util')\n\nfunction IncompleteBufferError (message) {\n  Error.call(this) // super constructor\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor) // super helper method to include stack trace in error object\n  }\n  this.name = this.constructor.name\n  this.message = message || 'unable to decode'\n}\n\nutil.inherits(IncompleteBufferError, Error)\n\nmodule.exports = function buildDecode (decodingTypes) {\n  return decode\n\n  function getSize (first) {\n    switch (first) {\n      case 0xc4:\n        return 2\n      case 0xc5:\n        return 3\n      case 0xc6:\n        return 5\n      case 0xc7:\n        return 3\n      case 0xc8:\n        return 4\n      case 0xc9:\n        return 6\n      case 0xca:\n        return 5\n      case 0xcb:\n        return 9\n      case 0xcc:\n        return 2\n      case 0xcd:\n        return 3\n      case 0xce:\n        return 5\n      case 0xcf:\n        return 9\n      case 0xd0:\n        return 2\n      case 0xd1:\n        return 3\n      case 0xd2:\n        return 5\n      case 0xd3:\n        return 9\n      case 0xd4:\n        return 3\n      case 0xd5:\n        return 4\n      case 0xd6:\n        return 6\n      case 0xd7:\n        return 10\n      case 0xd8:\n        return 18\n      case 0xd9:\n        return 2\n      case 0xda:\n        return 3\n      case 0xdb:\n        return 5\n      case 0xde:\n        return 3\n      default:\n        return -1\n    }\n  }\n\n  function hasMinBufferSize (first, length) {\n    var size = getSize(first)\n\n    if (size !== -1 && length < size) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  function isValidDataSize (dataLength, bufLength, headerLength) {\n    return bufLength >= headerLength + dataLength\n  }\n\n  function buildDecodeResult (value, bytesConsumed) {\n    return {\n      value: value,\n      bytesConsumed: bytesConsumed\n    }\n  }\n\n  function decode (buf) {\n    if (!(buf instanceof bl)) {\n      buf = bl().append(buf)\n    }\n\n    var result = tryDecode(buf)\n    if (result) {\n      buf.consume(result.bytesConsumed)\n      return result.value\n    } else {\n      throw new IncompleteBufferError()\n    }\n  }\n\n  function tryDecode (buf, offset) {\n    offset = offset === undefined ? 0 : offset\n    var bufLength = buf.length - offset\n    if (bufLength <= 0) {\n      return null\n    }\n\n    var first = buf.readUInt8(offset)\n    var length\n    var result = 0\n    var type\n    var bytePos\n\n    if (!hasMinBufferSize(first, bufLength)) {\n      return null\n    }\n\n    switch (first) {\n      case 0xc0:\n        return buildDecodeResult(null, 1)\n      case 0xc2:\n        return buildDecodeResult(false, 1)\n      case 0xc3:\n        return buildDecodeResult(true, 1)\n      case 0xcc:\n        // 1-byte unsigned int\n        result = buf.readUInt8(offset + 1)\n        return buildDecodeResult(result, 2)\n      case 0xcd:\n        // 2-bytes BE unsigned int\n        result = buf.readUInt16BE(offset + 1)\n        return buildDecodeResult(result, 3)\n      case 0xce:\n        // 4-bytes BE unsigned int\n        result = buf.readUInt32BE(offset + 1)\n        return buildDecodeResult(result, 5)\n      case 0xcf:\n        // 8-bytes BE unsigned int\n        // Read long byte by byte, big-endian\n        for (bytePos = 7; bytePos >= 0; bytePos--) {\n          result += (buf.readUInt8(offset + bytePos + 1) * Math.pow(2, (8 * (7 - bytePos))))\n        }\n        return buildDecodeResult(result, 9)\n      case 0xd0:\n        // 1-byte signed int\n        result = buf.readInt8(offset + 1)\n        return buildDecodeResult(result, 2)\n      case 0xd1:\n        // 2-bytes signed int\n        result = buf.readInt16BE(offset + 1)\n        return buildDecodeResult(result, 3)\n      case 0xd2:\n        // 4-bytes signed int\n        result = buf.readInt32BE(offset + 1)\n        return buildDecodeResult(result, 5)\n      case 0xd3:\n        result = readInt64BE(buf.slice(offset + 1, offset + 9), 0)\n        return buildDecodeResult(result, 9)\n      case 0xca:\n        // 4-bytes float\n        result = buf.readFloatBE(offset + 1)\n        return buildDecodeResult(result, 5)\n      case 0xcb:\n        // 8-bytes double\n        result = buf.readDoubleBE(offset + 1)\n        return buildDecodeResult(result, 9)\n      case 0xd9:\n        // strings up to 2^8 - 1 bytes\n        length = buf.readUInt8(offset + 1)\n        if (!isValidDataSize(length, bufLength, 2)) {\n          return null\n        }\n        result = buf.toString('utf8', offset + 2, offset + 2 + length)\n        return buildDecodeResult(result, 2 + length)\n      case 0xda:\n        // strings up to 2^16 - 2 bytes\n        length = buf.readUInt16BE(offset + 1)\n        if (!isValidDataSize(length, bufLength, 3)) {\n          return null\n        }\n        result = buf.toString('utf8', offset + 3, offset + 3 + length)\n        return buildDecodeResult(result, 3 + length)\n      case 0xdb:\n        // strings up to 2^32 - 4 bytes\n        length = buf.readUInt32BE(offset + 1)\n        if (!isValidDataSize(length, bufLength, 5)) {\n          return null\n        }\n        result = buf.toString('utf8', offset + 5, offset + 5 + length)\n        return buildDecodeResult(result, 5 + length)\n      case 0xc4:\n        // buffers up to 2^8 - 1 bytes\n        length = buf.readUInt8(offset + 1)\n        if (!isValidDataSize(length, bufLength, 2)) {\n          return null\n        }\n        result = buf.slice(offset + 2, offset + 2 + length)\n        return buildDecodeResult(result, 2 + length)\n      case 0xc5:\n        // buffers up to 2^16 - 1 bytes\n        length = buf.readUInt16BE(offset + 1)\n        if (!isValidDataSize(length, bufLength, 3)) {\n          return null\n        }\n        result = buf.slice(offset + 3, offset + 3 + length)\n        return buildDecodeResult(result, 3 + length)\n      case 0xc6:\n        // buffers up to 2^32 - 1 bytes\n        length = buf.readUInt32BE(offset + 1)\n        if (!isValidDataSize(length, bufLength, 5)) {\n          return null\n        }\n        result = buf.slice(offset + 5, offset + 5 + length)\n        return buildDecodeResult(result, 5 + length)\n      case 0xdc:\n        // array up to 2^16 elements - 2 bytes\n        if (bufLength < 3) {\n          return null\n        }\n\n        length = buf.readUInt16BE(offset + 1)\n        return decodeArray(buf, offset, length, 3)\n      case 0xdd:\n        // array up to 2^32 elements - 4 bytes\n        if (bufLength < 5) {\n          return null\n        }\n\n        length = buf.readUInt32BE(offset + 1)\n        return decodeArray(buf, offset, length, 5)\n      case 0xde:\n        // maps up to 2^16 elements - 2 bytes\n        length = buf.readUInt16BE(offset + 1)\n        return decodeMap(buf, offset, length, 3)\n      case 0xdf:\n        throw new Error('map too big to decode in JS')\n      case 0xd4:\n        return decodeFixExt(buf, offset, 1)\n      case 0xd5:\n        return decodeFixExt(buf, offset, 2)\n      case 0xd6:\n        return decodeFixExt(buf, offset, 4)\n      case 0xd7:\n        return decodeFixExt(buf, offset, 8)\n      case 0xd8:\n        return decodeFixExt(buf, offset, 16)\n      case 0xc7:\n        // ext up to 2^8 - 1 bytes\n        length = buf.readUInt8(offset + 1)\n        type = buf.readUInt8(offset + 2)\n        if (!isValidDataSize(length, bufLength, 3)) {\n          return null\n        }\n        return decodeExt(buf, offset, type, length, 3)\n      case 0xc8:\n        // ext up to 2^16 - 1 bytes\n        length = buf.readUInt16BE(offset + 1)\n        type = buf.readUInt8(offset + 3)\n        if (!isValidDataSize(length, bufLength, 4)) {\n          return null\n        }\n        return decodeExt(buf, offset, type, length, 4)\n      case 0xc9:\n        // ext up to 2^32 - 1 bytes\n        length = buf.readUInt32BE(offset + 1)\n        type = buf.readUInt8(offset + 5)\n        if (!isValidDataSize(length, bufLength, 6)) {\n          return null\n        }\n        return decodeExt(buf, offset, type, length, 6)\n    }\n\n    if ((first & 0xf0) === 0x90) {\n      // we have an array with less than 15 elements\n      length = first & 0x0f\n      return decodeArray(buf, offset, length, 1)\n    } else if ((first & 0xf0) === 0x80) {\n      // we have a map with less than 15 elements\n      length = first & 0x0f\n      return decodeMap(buf, offset, length, 1)\n    } else if ((first & 0xe0) === 0xa0) {\n      // fixstr up to 31 bytes\n      length = first & 0x1f\n      if (isValidDataSize(length, bufLength, 1)) {\n        result = buf.toString('utf8', offset + 1, offset + length + 1)\n        return buildDecodeResult(result, length + 1)\n      } else {\n        return null\n      }\n    } else if (first >= 0xe0) {\n      // 5 bits negative ints\n      result = first - 0x100\n      return buildDecodeResult(result, 1)\n    } else if (first < 0x80) {\n      // 7-bits positive ints\n      return buildDecodeResult(first, 1)\n    } else {\n      throw new Error('not implemented yet')\n    }\n  }\n\n  function readInt64BE (buf, offset) {\n    var negate = (buf[offset] & 0x80) == 0x80 // eslint-disable-line\n\n    if (negate) {\n      var carry = 1\n      for (var i = offset + 7; i >= offset; i--) {\n        var v = (buf[i] ^ 0xff) + carry\n        buf[i] = v & 0xff\n        carry = v >> 8\n      }\n    }\n\n    var hi = buf.readUInt32BE(offset + 0)\n    var lo = buf.readUInt32BE(offset + 4)\n    return (hi * 4294967296 + lo) * (negate ? -1 : +1)\n  }\n\n  function decodeArray (buf, offset, length, headerLength) {\n    var result = []\n    var i\n    var totalBytesConsumed = 0\n\n    offset += headerLength\n    for (i = 0; i < length; i++) {\n      var decodeResult = tryDecode(buf, offset)\n      if (decodeResult) {\n        result.push(decodeResult.value)\n        offset += decodeResult.bytesConsumed\n        totalBytesConsumed += decodeResult.bytesConsumed\n      } else {\n        return null\n      }\n    }\n    return buildDecodeResult(result, headerLength + totalBytesConsumed)\n  }\n\n  function decodeMap (buf, offset, length, headerLength) {\n    var result = {}\n    var key\n    var i\n    var totalBytesConsumed = 0\n\n    offset += headerLength\n    for (i = 0; i < length; i++) {\n      var keyResult = tryDecode(buf, offset)\n      if (keyResult) {\n        offset += keyResult.bytesConsumed\n        var valueResult = tryDecode(buf, offset)\n        if (valueResult) {\n          key = keyResult.value\n          result[key] = valueResult.value\n          offset += valueResult.bytesConsumed\n          totalBytesConsumed += (keyResult.bytesConsumed + valueResult.bytesConsumed)\n        } else {\n          return null\n        }\n      } else {\n        return null\n      }\n    }\n    return buildDecodeResult(result, headerLength + totalBytesConsumed)\n  }\n\n  function decodeFixExt (buf, offset, size) {\n    var type = buf.readInt8(offset + 1) // Signed\n    return decodeExt(buf, offset, type, size, 2)\n  }\n  function decodeTimestamp (buf, size, headerSize) {\n    var seconds, nanoseconds\n    nanoseconds = 0\n\n    switch (size) {\n      case 4:\n          // timestamp 32 stores the number of seconds that have elapsed since 1970-01-01 00:00:00 UTC in an 32-bit unsigned integer\n        seconds = buf.readUInt32BE(0)\n        break\n\n      case 8: // Timestamp 64 stores the number of seconds and nanoseconds that have elapsed\n                // since 1970-01-01 00:00:00 UTC in 32-bit unsigned integers, split 30/34 bits\n        var upper = buf.readUInt32BE(0)\n        var lower = buf.readUInt32BE(4)\n        nanoseconds = upper / 4\n        seconds = ((upper & 0x03) * Math.pow(2, 32)) + lower // If we use bitwise operators, we get truncated to 32bits\n        break\n\n      case 12:\n        throw new Error('timestamp 96 is not yet implemented')\n    }\n\n    var millis = (seconds * 1000) + Math.round(nanoseconds / 1E6)\n    return buildDecodeResult(new Date(millis), size + headerSize)\n  }\n\n  function decodeExt (buf, offset, type, size, headerSize) {\n    var i,\n      toDecode\n\n    offset += headerSize\n\n    // Pre-defined\n    if (type < 0) { // Reserved for future extensions\n      switch (type) {\n        case -1: // Tiemstamp https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\n          toDecode = buf.slice(offset, offset + size)\n          return decodeTimestamp(toDecode, size, headerSize)\n      }\n    }\n\n    for (i = 0; i < decodingTypes.length; i++) {\n      if (type === decodingTypes[i].type) {\n        toDecode = buf.slice(offset, offset + size)\n        var value = decodingTypes[i].decode(toDecode)\n        return buildDecodeResult(value, headerSize + size)\n      }\n    }\n\n    throw new Error('unable to find ext type ' + type)\n  }\n}\n\nmodule.exports.IncompleteBufferError = IncompleteBufferError\n","'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar bl = require('bl')\nvar TOLERANCE = 0.1\n\nmodule.exports = function buildEncode (encodingTypes, forceFloat64, compatibilityMode, disableTimestampEncoding) {\n  function encode (obj, avoidSlice) {\n    var buf,\n      len\n\n    if (obj === undefined) {\n      throw new Error('undefined is not encodable in msgpack!')\n    } else if (obj === null) {\n      buf = Buffer.allocUnsafe(1)\n      buf[0] = 0xc0\n    } else if (obj === true) {\n      buf = Buffer.allocUnsafe(1)\n      buf[0] = 0xc3\n    } else if (obj === false) {\n      buf = Buffer.allocUnsafe(1)\n      buf[0] = 0xc2\n    } else if (typeof obj === 'string') {\n      len = Buffer.byteLength(obj)\n      if (len < 32) {\n        buf = Buffer.allocUnsafe(1 + len)\n        buf[0] = 0xa0 | len\n        if (len > 0) {\n          buf.write(obj, 1)\n        }\n      } else if (len <= 0xff && !compatibilityMode) {\n        // str8, but only when not in compatibility mode\n        buf = Buffer.allocUnsafe(2 + len)\n        buf[0] = 0xd9\n        buf[1] = len\n        buf.write(obj, 2)\n      } else if (len <= 0xffff) {\n        buf = Buffer.allocUnsafe(3 + len)\n        buf[0] = 0xda\n        buf.writeUInt16BE(len, 1)\n        buf.write(obj, 3)\n      } else {\n        buf = Buffer.allocUnsafe(5 + len)\n        buf[0] = 0xdb\n        buf.writeUInt32BE(len, 1)\n        buf.write(obj, 5)\n      }\n    } else if (obj && (obj.readUInt32LE || obj instanceof Uint8Array)) {\n      if (obj instanceof Uint8Array) {\n        obj = Buffer.from(obj)\n      }\n      // weird hack to support Buffer\n      // and Buffer-like objects\n      if (obj.length <= 0xff) {\n        buf = Buffer.allocUnsafe(2)\n        buf[0] = 0xc4\n        buf[1] = obj.length\n      } else if (obj.length <= 0xffff) {\n        buf = Buffer.allocUnsafe(3)\n        buf[0] = 0xc5\n        buf.writeUInt16BE(obj.length, 1)\n      } else {\n        buf = Buffer.allocUnsafe(5)\n        buf[0] = 0xc6\n        buf.writeUInt32BE(obj.length, 1)\n      }\n\n      buf = bl([buf, obj])\n    } else if (Array.isArray(obj)) {\n      if (obj.length < 16) {\n        buf = Buffer.allocUnsafe(1)\n        buf[0] = 0x90 | obj.length\n      } else if (obj.length < 65536) {\n        buf = Buffer.allocUnsafe(3)\n        buf[0] = 0xdc\n        buf.writeUInt16BE(obj.length, 1)\n      } else {\n        buf = Buffer.allocUnsafe(5)\n        buf[0] = 0xdd\n        buf.writeUInt32BE(obj.length, 1)\n      }\n\n      buf = obj.reduce(function (acc, obj) {\n        acc.append(encode(obj, true))\n        return acc\n      }, bl().append(buf))\n    } else if (!disableTimestampEncoding && typeof obj.getDate === 'function') {\n      return encodeDate(obj)\n    } else if (typeof obj === 'object') {\n      buf = encodeExt(obj) || encodeObject(obj)\n    } else if (typeof obj === 'number') {\n      if (isFloat(obj)) {\n        return encodeFloat(obj, forceFloat64)\n      } else if (obj >= 0) {\n        if (obj < 128) {\n          buf = Buffer.allocUnsafe(1)\n          buf[0] = obj\n        } else if (obj < 256) {\n          buf = Buffer.allocUnsafe(2)\n          buf[0] = 0xcc\n          buf[1] = obj\n        } else if (obj < 65536) {\n          buf = Buffer.allocUnsafe(3)\n          buf[0] = 0xcd\n          buf.writeUInt16BE(obj, 1)\n        } else if (obj <= 0xffffffff) {\n          buf = Buffer.allocUnsafe(5)\n          buf[0] = 0xce\n          buf.writeUInt32BE(obj, 1)\n        } else if (obj <= 9007199254740991) {\n          buf = Buffer.allocUnsafe(9)\n          buf[0] = 0xcf\n          write64BitUint(buf, obj)\n        } else {\n          return encodeFloat(obj, true)\n        }\n      } else {\n        if (obj >= -32) {\n          buf = Buffer.allocUnsafe(1)\n          buf[0] = 0x100 + obj\n        } else if (obj >= -128) {\n          buf = Buffer.allocUnsafe(2)\n          buf[0] = 0xd0\n          buf.writeInt8(obj, 1)\n        } else if (obj >= -32768) {\n          buf = Buffer.allocUnsafe(3)\n          buf[0] = 0xd1\n          buf.writeInt16BE(obj, 1)\n        } else if (obj > -214748365) {\n          buf = Buffer.allocUnsafe(5)\n          buf[0] = 0xd2\n          buf.writeInt32BE(obj, 1)\n        } else if (obj >= -9007199254740991) {\n          buf = Buffer.allocUnsafe(9)\n          buf[0] = 0xd3\n          write64BitInt(buf, 1, obj)\n        } else {\n          return encodeFloat(obj, true)\n        }\n      }\n    }\n\n    if (!buf) {\n      throw new Error('not implemented yet')\n    }\n\n    if (avoidSlice) {\n      return buf\n    } else {\n      return buf.slice()\n    }\n  }\n\n  function encodeDate (dt) {\n    var encoded\n    var millis = dt * 1\n    var seconds = Math.floor(millis / 1000)\n    var nanos = (millis - (seconds * 1000)) * 1E6\n\n    if (nanos || seconds > 0xFFFFFFFF) {\n        // Timestamp64\n      encoded = new Buffer(10)\n      encoded[0] = 0xd7\n      encoded[1] = -1\n\n      var upperNanos = ((nanos * 4))\n      var upperSeconds = seconds / Math.pow(2, 32)\n      var upper = (upperNanos + upperSeconds) & 0xFFFFFFFF\n      var lower = seconds & 0xFFFFFFFF\n\n      encoded.writeInt32BE(upper, 2)\n      encoded.writeInt32BE(lower, 6)\n    } else {\n        // Timestamp32\n      encoded = new Buffer(6)\n      encoded[0] = 0xd6\n      encoded[1] = -1\n      encoded.writeUInt32BE(Math.floor(millis / 1000), 2)\n    }\n    return bl().append(encoded)\n  }\n\n  function encodeExt (obj) {\n    var i\n    var encoded\n    var length = -1\n    var headers = []\n\n    for (i = 0; i < encodingTypes.length; i++) {\n      if (encodingTypes[i].check(obj)) {\n        encoded = encodingTypes[i].encode(obj)\n        break\n      }\n    }\n\n    if (!encoded) {\n      return null\n    }\n\n    // we subtract 1 because the length does not\n    // include the type\n    length = encoded.length - 1\n\n    if (length === 1) {\n      headers.push(0xd4)\n    } else if (length === 2) {\n      headers.push(0xd5)\n    } else if (length === 4) {\n      headers.push(0xd6)\n    } else if (length === 8) {\n      headers.push(0xd7)\n    } else if (length === 16) {\n      headers.push(0xd8)\n    } else if (length < 256) {\n      headers.push(0xc7)\n      headers.push(length)\n    } else if (length < 0x10000) {\n      headers.push(0xc8)\n      headers.push(length >> 8)\n      headers.push(length & 0x00ff)\n    } else {\n      headers.push(0xc9)\n      headers.push(length >> 24)\n      headers.push((length >> 16) & 0x000000ff)\n      headers.push((length >> 8) & 0x000000ff)\n      headers.push(length & 0x000000ff)\n    }\n\n    return bl().append(Buffer.from(headers)).append(encoded)\n  }\n\n  function encodeObject (obj) {\n    var acc = []\n    var length = 0\n    var key\n    var header\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key) &&\n        obj[key] !== undefined &&\n        typeof obj[key] !== 'function') {\n        ++length\n        acc.push(encode(key, true))\n        acc.push(encode(obj[key], true))\n      }\n    }\n\n    if (length < 16) {\n      header = Buffer.allocUnsafe(1)\n      header[0] = 0x80 | length\n    } else {\n      header = Buffer.allocUnsafe(3)\n      header[0] = 0xde\n      header.writeUInt16BE(length, 1)\n    }\n\n    acc.unshift(header)\n\n    var result = acc.reduce(function (list, buf) {\n      return list.append(buf)\n    }, bl())\n\n    return result\n  }\n\n  return encode\n}\n\nfunction write64BitUint (buf, obj) {\n  // Write long byte by byte, in big-endian order\n  for (var currByte = 7; currByte >= 0; currByte--) {\n    buf[currByte + 1] = (obj & 0xff)\n    obj = obj / 256\n  }\n}\n\nfunction write64BitInt (buf, offset, num) {\n  var negate = num < 0\n\n  if (negate) {\n    num = Math.abs(num)\n  }\n\n  var lo = num % 4294967296\n  var hi = num / 4294967296\n  buf.writeUInt32BE(Math.floor(hi), offset + 0)\n  buf.writeUInt32BE(lo, offset + 4)\n\n  if (negate) {\n    var carry = 1\n    for (var i = offset + 7; i >= offset; i--) {\n      var v = (buf[i] ^ 0xff) + carry\n      buf[i] = v & 0xff\n      carry = v >> 8\n    }\n  }\n}\n\nfunction isFloat (n) {\n  return n !== Math.floor(n)\n}\n\nfunction encodeFloat (obj, forceFloat64) {\n  var buf\n\n  buf = Buffer.allocUnsafe(5)\n  buf[0] = 0xca\n  buf.writeFloatBE(obj, 1)\n\n  // FIXME is there a way to check if a\n  // value fits in a float?\n  if (forceFloat64 || Math.abs(obj - buf.readFloatBE(1)) > TOLERANCE) {\n    buf = Buffer.allocUnsafe(9)\n    buf[0] = 0xcb\n    buf.writeDoubleBE(obj, 1)\n  }\n\n  return buf\n}\n","'use strict'\n\nvar Transform = require('readable-stream').Transform\nvar inherits = require('inherits')\nvar bl = require('bl')\n\nfunction Base (opts) {\n  opts = opts || {}\n\n  opts.objectMode = true\n  opts.highWaterMark = 16\n\n  Transform.call(this, opts)\n\n  this._msgpack = opts.msgpack\n}\n\ninherits(Base, Transform)\n\nfunction Encoder (opts) {\n  if (!(this instanceof Encoder)) {\n    opts = opts || {}\n    opts.msgpack = this\n    return new Encoder(opts)\n  }\n\n  Base.call(this, opts)\n}\n\ninherits(Encoder, Base)\n\nEncoder.prototype._transform = function (obj, enc, done) {\n  var buf = null\n\n  try {\n    buf = this._msgpack.encode(obj).slice(0)\n  } catch (err) {\n    this.emit('error', err)\n    return done()\n  }\n\n  this.push(buf)\n  done()\n}\n\nfunction Decoder (opts) {\n  if (!(this instanceof Decoder)) {\n    opts = opts || {}\n    opts.msgpack = this\n    return new Decoder(opts)\n  }\n\n  Base.call(this, opts)\n\n  this._chunks = bl()\n}\n\ninherits(Decoder, Base)\n\nDecoder.prototype._transform = function (buf, enc, done) {\n  if (buf) {\n    this._chunks.append(buf)\n  }\n\n  try {\n    var result = this._msgpack.decode(this._chunks)\n    this.push(result)\n  } catch (err) {\n    if (err instanceof this._msgpack.IncompleteBufferError) {\n      done()\n    } else {\n      this.emit('error', err)\n    }\n    return\n  }\n\n  if (this._chunks.length > 0) {\n    this._transform(null, enc, done)\n  } else {\n    done()\n  }\n}\n\nmodule.exports.decoder = Decoder\nmodule.exports.encoder = Encoder\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","module.exports = require('./lib/_stream_duplex.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n// Not exported from index.\r\n/** @private */\r\nvar AbortController = /** @class */ (function () {\r\n    function AbortController() {\r\n        this.isAborted = false;\r\n        this.onabort = null;\r\n    }\r\n    AbortController.prototype.abort = function () {\r\n        if (!this.isAborted) {\r\n            this.isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(AbortController.prototype, \"signal\", {\r\n        get: function () {\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbortController.prototype, \"aborted\", {\r\n        get: function () {\r\n            return this.isAborted;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return AbortController;\r\n}());\r\nexport { AbortController };\r\n//# sourceMappingURL=AbortController.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { AbortError } from \"./Errors\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { NodeHttpClient } from \"./NodeHttpClient\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n/** Default implementation of {@link @aspnet/signalr.HttpClient}. */\r\nvar DefaultHttpClient = /** @class */ (function (_super) {\r\n    __extends(DefaultHttpClient, _super);\r\n    /** Creates a new instance of the {@link @aspnet/signalr.DefaultHttpClient}, using the provided {@link @aspnet/signalr.ILogger} to log messages. */\r\n    function DefaultHttpClient(logger) {\r\n        var _this = _super.call(this) || this;\r\n        if (typeof XMLHttpRequest !== \"undefined\") {\r\n            _this.httpClient = new XhrHttpClient(logger);\r\n        }\r\n        else {\r\n            _this.httpClient = new NodeHttpClient(logger);\r\n        }\r\n        return _this;\r\n    }\r\n    /** @inheritDoc */\r\n    DefaultHttpClient.prototype.send = function (request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return this.httpClient.send(request);\r\n    };\r\n    DefaultHttpClient.prototype.getCookieString = function (url) {\r\n        return this.httpClient.getCookieString(url);\r\n    };\r\n    return DefaultHttpClient;\r\n}(HttpClient));\r\nexport { DefaultHttpClient };\r\n//# sourceMappingURL=DefaultHttpClient.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nvar DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n/** @private */\r\nvar DefaultReconnectPolicy = /** @class */ (function () {\r\n    function DefaultReconnectPolicy(retryDelays) {\r\n        this.retryDelays = retryDelays !== undefined ? retryDelays.concat([null]) : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n    DefaultReconnectPolicy.prototype.nextRetryDelayInMilliseconds = function (retryContext) {\r\n        return this.retryDelays[retryContext.previousRetryCount];\r\n    };\r\n    return DefaultReconnectPolicy;\r\n}());\r\nexport { DefaultReconnectPolicy };\r\n//# sourceMappingURL=DefaultReconnectPolicy.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/** Error thrown when an HTTP request fails. */\r\nvar HttpError = /** @class */ (function (_super) {\r\n    __extends(HttpError, _super);\r\n    /** Constructs a new instance of {@link @aspnet/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    function HttpError(errorMessage, statusCode) {\r\n        var _newTarget = this.constructor;\r\n        var _this = this;\r\n        var trueProto = _newTarget.prototype;\r\n        _this = _super.call(this, errorMessage) || this;\r\n        _this.statusCode = statusCode;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        _this.__proto__ = trueProto;\r\n        return _this;\r\n    }\r\n    return HttpError;\r\n}(Error));\r\nexport { HttpError };\r\n/** Error thrown when a timeout elapses. */\r\nvar TimeoutError = /** @class */ (function (_super) {\r\n    __extends(TimeoutError, _super);\r\n    /** Constructs a new instance of {@link @aspnet/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    function TimeoutError(errorMessage) {\r\n        var _newTarget = this.constructor;\r\n        if (errorMessage === void 0) { errorMessage = \"A timeout occurred.\"; }\r\n        var _this = this;\r\n        var trueProto = _newTarget.prototype;\r\n        _this = _super.call(this, errorMessage) || this;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        _this.__proto__ = trueProto;\r\n        return _this;\r\n    }\r\n    return TimeoutError;\r\n}(Error));\r\nexport { TimeoutError };\r\n/** Error thrown when an action is aborted. */\r\nvar AbortError = /** @class */ (function (_super) {\r\n    __extends(AbortError, _super);\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    function AbortError(errorMessage) {\r\n        var _newTarget = this.constructor;\r\n        if (errorMessage === void 0) { errorMessage = \"An abort occurred.\"; }\r\n        var _this = this;\r\n        var trueProto = _newTarget.prototype;\r\n        _this = _super.call(this, errorMessage) || this;\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        _this.__proto__ = trueProto;\r\n        return _this;\r\n    }\r\n    return AbortError;\r\n}(Error));\r\nexport { AbortError };\r\n//# sourceMappingURL=Errors.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nvar HandshakeProtocol = /** @class */ (function () {\r\n    function HandshakeProtocol() {\r\n    }\r\n    // Handshake request is always JSON\r\n    HandshakeProtocol.prototype.writeHandshakeRequest = function (handshakeRequest) {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    };\r\n    HandshakeProtocol.prototype.parseHandshakeResponse = function (data) {\r\n        var responseMessage;\r\n        var messageData;\r\n        var remainingData;\r\n        if (isArrayBuffer(data) || (typeof Buffer !== \"undefined\" && data instanceof Buffer)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            var binaryData = new Uint8Array(data);\r\n            var separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            var responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        }\r\n        else {\r\n            var textData = data;\r\n            var separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            var responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n        // At this point we should have just the single handshake message\r\n        var messages = TextMessageFormat.parse(messageData);\r\n        var response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        responseMessage = response;\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    };\r\n    return HandshakeProtocol;\r\n}());\r\nexport { HandshakeProtocol };\r\n//# sourceMappingURL=HandshakeProtocol.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\n/** Represents an HTTP response. */\r\nvar HttpResponse = /** @class */ (function () {\r\n    function HttpResponse(statusCode, statusText, content) {\r\n        this.statusCode = statusCode;\r\n        this.statusText = statusText;\r\n        this.content = content;\r\n    }\r\n    return HttpResponse;\r\n}());\r\nexport { HttpResponse };\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nvar HttpClient = /** @class */ (function () {\r\n    function HttpClient() {\r\n    }\r\n    HttpClient.prototype.get = function (url, options) {\r\n        return this.send(__assign({}, options, { method: \"GET\", url: url }));\r\n    };\r\n    HttpClient.prototype.post = function (url, options) {\r\n        return this.send(__assign({}, options, { method: \"POST\", url: url }));\r\n    };\r\n    HttpClient.prototype.delete = function (url, options) {\r\n        return this.send(__assign({}, options, { method: \"DELETE\", url: url }));\r\n    };\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    HttpClient.prototype.getCookieString = function (url) {\r\n        return \"\";\r\n    };\r\n    return HttpClient;\r\n}());\r\nexport { HttpClient };\r\n//# sourceMappingURL=HttpClient.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\nvar MAX_REDIRECTS = 100;\r\nvar WebSocketModule = null;\r\nvar EventSourceModule = null;\r\nif (Platform.isNode && typeof require !== \"undefined\") {\r\n    // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n    // @ts-ignore: TS doesn't know about these names\r\n    var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n    WebSocketModule = requireFunc(\"ws\");\r\n    EventSourceModule = requireFunc(\"eventsource\");\r\n}\r\n/** @private */\r\nvar HttpConnection = /** @class */ (function () {\r\n    function HttpConnection(url, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.features = {};\r\n        Arg.isRequired(url, \"url\");\r\n        this.logger = createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent || false;\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        }\r\n        else if (Platform.isNode && !options.WebSocket) {\r\n            if (WebSocketModule) {\r\n                options.WebSocket = WebSocketModule;\r\n            }\r\n        }\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        }\r\n        else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof EventSourceModule !== \"undefined\") {\r\n                options.EventSource = EventSourceModule;\r\n            }\r\n        }\r\n        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\r\n        this.connectionState = \"Disconnected\" /* Disconnected */;\r\n        this.connectionStarted = false;\r\n        this.options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    HttpConnection.prototype.start = function (transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var message, message;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        transferFormat = transferFormat || TransferFormat.Binary;\r\n                        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n                        this.logger.log(LogLevel.Debug, \"Starting connection with transfer format '\" + TransferFormat[transferFormat] + \"'.\");\r\n                        if (this.connectionState !== \"Disconnected\" /* Disconnected */) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"))];\r\n                        }\r\n                        this.connectionState = \"Connecting \" /* Connecting */;\r\n                        this.startInternalPromise = this.startInternal(transferFormat);\r\n                        return [4 /*yield*/, this.startInternalPromise];\r\n                    case 1:\r\n                        _a.sent();\r\n                        if (!(this.connectionState === \"Disconnecting\" /* Disconnecting */)) return [3 /*break*/, 3];\r\n                        message = \"Failed to start the HttpConnection before stop() was called.\";\r\n                        this.logger.log(LogLevel.Error, message);\r\n                        // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n                        return [4 /*yield*/, this.stopPromise];\r\n                    case 2:\r\n                        // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n                        _a.sent();\r\n                        return [2 /*return*/, Promise.reject(new Error(message))];\r\n                    case 3:\r\n                        if (this.connectionState !== \"Connected\" /* Connected */) {\r\n                            message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n                            this.logger.log(LogLevel.Error, message);\r\n                            return [2 /*return*/, Promise.reject(new Error(message))];\r\n                        }\r\n                        _a.label = 4;\r\n                    case 4:\r\n                        this.connectionStarted = true;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.send = function (data) {\r\n        if (this.connectionState !== \"Connected\" /* Connected */) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n        if (!this.sendQueue) {\r\n            this.sendQueue = new TransportSendQueue(this.transport);\r\n        }\r\n        // Transport will not be null if state is connected\r\n        return this.sendQueue.send(data);\r\n    };\r\n    HttpConnection.prototype.stop = function (error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (this.connectionState === \"Disconnected\" /* Disconnected */) {\r\n                            this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnected state.\");\r\n                            return [2 /*return*/, Promise.resolve()];\r\n                        }\r\n                        if (this.connectionState === \"Disconnecting\" /* Disconnecting */) {\r\n                            this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\r\n                            return [2 /*return*/, this.stopPromise];\r\n                        }\r\n                        this.connectionState = \"Disconnecting\" /* Disconnecting */;\r\n                        this.stopPromise = new Promise(function (resolve) {\r\n                            // Don't complete stop() until stopConnection() completes.\r\n                            _this.stopPromiseResolver = resolve;\r\n                        });\r\n                        // stopInternal should never throw so just observe it.\r\n                        return [4 /*yield*/, this.stopInternal(error)];\r\n                    case 1:\r\n                        // stopInternal should never throw so just observe it.\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.stopPromise];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.stopInternal = function (error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var e_1, e_2, e_3;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        // Set error as soon as possible otherwise there is a race between\r\n                        // the transport closing and providing an error and the error from a close message\r\n                        // We would prefer the close message error.\r\n                        this.stopError = error;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.startInternalPromise];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 4:\r\n                        if (!this.sendQueue) return [3 /*break*/, 9];\r\n                        _a.label = 5;\r\n                    case 5:\r\n                        _a.trys.push([5, 7, , 8]);\r\n                        return [4 /*yield*/, this.sendQueue.stop()];\r\n                    case 6:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        e_2 = _a.sent();\r\n                        this.logger.log(LogLevel.Error, \"TransportSendQueue.stop() threw error '\" + e_2 + \"'.\");\r\n                        return [3 /*break*/, 8];\r\n                    case 8:\r\n                        this.sendQueue = undefined;\r\n                        _a.label = 9;\r\n                    case 9:\r\n                        if (!this.transport) return [3 /*break*/, 14];\r\n                        _a.label = 10;\r\n                    case 10:\r\n                        _a.trys.push([10, 12, , 13]);\r\n                        return [4 /*yield*/, this.transport.stop()];\r\n                    case 11:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 13];\r\n                    case 12:\r\n                        e_3 = _a.sent();\r\n                        this.logger.log(LogLevel.Error, \"HttpConnection.transport.stop() threw error '\" + e_3 + \"'.\");\r\n                        this.stopConnection();\r\n                        return [3 /*break*/, 13];\r\n                    case 13:\r\n                        this.transport = undefined;\r\n                        return [3 /*break*/, 15];\r\n                    case 14:\r\n                        this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n                        this.stopConnection();\r\n                        _a.label = 15;\r\n                    case 15: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.startInternal = function (transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, negotiateResponse, redirects, _loop_1, this_1, e_4;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = this.baseUrl;\r\n                        this.accessTokenFactory = this.options.accessTokenFactory;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 12, , 13]);\r\n                        if (!this.options.skipNegotiation) return [3 /*break*/, 5];\r\n                        if (!(this.options.transport === HttpTransportType.WebSockets)) return [3 /*break*/, 3];\r\n                        // No need to add a connection ID in this case\r\n                        this.transport = this.constructTransport(HttpTransportType.WebSockets);\r\n                        // We should just call connect directly in this case.\r\n                        // No fallback or negotiate in this case.\r\n                        return [4 /*yield*/, this.transport.connect(url, transferFormat)];\r\n                    case 2:\r\n                        // We should just call connect directly in this case.\r\n                        // No fallback or negotiate in this case.\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3: throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                    case 4: return [3 /*break*/, 11];\r\n                    case 5:\r\n                        negotiateResponse = null;\r\n                        redirects = 0;\r\n                        _loop_1 = function () {\r\n                            var accessToken_1;\r\n                            return __generator(this, function (_a) {\r\n                                switch (_a.label) {\r\n                                    case 0: return [4 /*yield*/, this_1.getNegotiationResponse(url)];\r\n                                    case 1:\r\n                                        negotiateResponse = _a.sent();\r\n                                        // the user tries to stop the connection when it is being started\r\n                                        if (this_1.connectionState === \"Disconnecting\" /* Disconnecting */ || this_1.connectionState === \"Disconnected\" /* Disconnected */) {\r\n                                            throw new Error(\"The connection was stopped during negotiation.\");\r\n                                        }\r\n                                        if (negotiateResponse.error) {\r\n                                            throw new Error(negotiateResponse.error);\r\n                                        }\r\n                                        if (negotiateResponse.ProtocolVersion) {\r\n                                            throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                                        }\r\n                                        if (negotiateResponse.url) {\r\n                                            url = negotiateResponse.url;\r\n                                        }\r\n                                        if (negotiateResponse.accessToken) {\r\n                                            accessToken_1 = negotiateResponse.accessToken;\r\n                                            this_1.accessTokenFactory = function () { return accessToken_1; };\r\n                                        }\r\n                                        redirects++;\r\n                                        return [2 /*return*/];\r\n                                }\r\n                            });\r\n                        };\r\n                        this_1 = this;\r\n                        _a.label = 6;\r\n                    case 6: return [5 /*yield**/, _loop_1()];\r\n                    case 7:\r\n                        _a.sent();\r\n                        _a.label = 8;\r\n                    case 8:\r\n                        if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3 /*break*/, 6];\r\n                        _a.label = 9;\r\n                    case 9:\r\n                        if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                            throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                        }\r\n                        this.connectionId = negotiateResponse.connectionId;\r\n                        return [4 /*yield*/, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];\r\n                    case 10:\r\n                        _a.sent();\r\n                        _a.label = 11;\r\n                    case 11:\r\n                        if (this.transport instanceof LongPollingTransport) {\r\n                            this.features.inherentKeepAlive = true;\r\n                        }\r\n                        this.transport.onreceive = this.onreceive;\r\n                        this.transport.onclose = function (e) { return _this.stopConnection(e); };\r\n                        if (this.connectionState === \"Connecting \" /* Connecting */) {\r\n                            // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                            // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                            this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                            this.connectionState = \"Connected\" /* Connected */;\r\n                        }\r\n                        return [3 /*break*/, 13];\r\n                    case 12:\r\n                        e_4 = _a.sent();\r\n                        this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e_4);\r\n                        this.connectionState = \"Disconnected\" /* Disconnected */;\r\n                        this.transport = undefined;\r\n                        return [2 /*return*/, Promise.reject(e_4)];\r\n                    case 13: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.getNegotiationResponse = function (url) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a, headers, token, negotiateUrl, response, e_5;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        if (!this.accessTokenFactory) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.accessTokenFactory()];\r\n                    case 1:\r\n                        token = _b.sent();\r\n                        if (token) {\r\n                            headers = (_a = {},\r\n                                _a[\"Authorization\"] = \"Bearer \" + token,\r\n                                _a);\r\n                        }\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        negotiateUrl = this.resolveNegotiateUrl(url);\r\n                        this.logger.log(LogLevel.Debug, \"Sending negotiation request: \" + negotiateUrl + \".\");\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        _b.trys.push([3, 5, , 6]);\r\n                        return [4 /*yield*/, this.httpClient.post(negotiateUrl, {\r\n                                content: \"\",\r\n                                headers: headers,\r\n                            })];\r\n                    case 4:\r\n                        response = _b.sent();\r\n                        if (response.statusCode !== 200) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Unexpected status code returned from negotiate \" + response.statusCode))];\r\n                        }\r\n                        return [2 /*return*/, JSON.parse(response.content)];\r\n                    case 5:\r\n                        e_5 = _b.sent();\r\n                        this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e_5);\r\n                        return [2 /*return*/, Promise.reject(e_5)];\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.createConnectUrl = function (url, connectionId) {\r\n        if (!connectionId) {\r\n            return url;\r\n        }\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + (\"id=\" + connectionId);\r\n    };\r\n    HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var connectUrl, transportExceptions, transports, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\r\n                        if (!this.isITransport(requestedTransport)) return [3 /*break*/, 2];\r\n                        this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n                        this.transport = requestedTransport;\r\n                        return [4 /*yield*/, this.transport.connect(connectUrl, requestedTransferFormat)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                    case 2:\r\n                        transportExceptions = [];\r\n                        transports = negotiateResponse.availableTransports || [];\r\n                        _i = 0, transports_1 = transports;\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        if (!(_i < transports_1.length)) return [3 /*break*/, 13];\r\n                        endpoint = transports_1[_i];\r\n                        transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n                        if (!(transportOrError instanceof Error)) return [3 /*break*/, 4];\r\n                        // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                        transportExceptions.push(endpoint.transport + \" failed: \" + transportOrError);\r\n                        return [3 /*break*/, 12];\r\n                    case 4:\r\n                        if (!this.isITransport(transportOrError)) return [3 /*break*/, 12];\r\n                        this.transport = transportOrError;\r\n                        if (!!negotiateResponse.connectionId) return [3 /*break*/, 9];\r\n                        _a.label = 5;\r\n                    case 5:\r\n                        _a.trys.push([5, 7, , 8]);\r\n                        return [4 /*yield*/, this.getNegotiationResponse(url)];\r\n                    case 6:\r\n                        negotiateResponse = _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        ex_1 = _a.sent();\r\n                        return [2 /*return*/, Promise.reject(ex_1)];\r\n                    case 8:\r\n                        connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\r\n                        _a.label = 9;\r\n                    case 9:\r\n                        _a.trys.push([9, 11, , 12]);\r\n                        return [4 /*yield*/, this.transport.connect(connectUrl, requestedTransferFormat)];\r\n                    case 10:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                    case 11:\r\n                        ex_2 = _a.sent();\r\n                        this.logger.log(LogLevel.Error, \"Failed to start the transport '\" + endpoint.transport + \"': \" + ex_2);\r\n                        negotiateResponse.connectionId = undefined;\r\n                        transportExceptions.push(endpoint.transport + \" failed: \" + ex_2);\r\n                        if (this.connectionState !== \"Connecting \" /* Connecting */) {\r\n                            message = \"Failed to select transport before stop() was called.\";\r\n                            this.logger.log(LogLevel.Debug, message);\r\n                            return [2 /*return*/, Promise.reject(new Error(message))];\r\n                        }\r\n                        return [3 /*break*/, 12];\r\n                    case 12:\r\n                        _i++;\r\n                        return [3 /*break*/, 3];\r\n                    case 13:\r\n                        if (transportExceptions.length > 0) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Unable to connect to the server with any of the available transports. \" + transportExceptions.join(\" \")))];\r\n                        }\r\n                        return [2 /*return*/, Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"))];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpConnection.prototype.constructTransport = function (transport) {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this.options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this.options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);\r\n            default:\r\n                throw new Error(\"Unknown transport: \" + transport + \".\");\r\n        }\r\n    };\r\n    HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {\r\n        var transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(LogLevel.Debug, \"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\r\n            return new Error(\"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\r\n        }\r\n        else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                var transferFormats = endpoint.transferFormats.map(function (s) { return TransferFormat[s]; });\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {\r\n                        this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it is not supported in your environment.'\");\r\n                        return new Error(\"'\" + HttpTransportType[transport] + \"' is not supported in your environment.\");\r\n                    }\r\n                    else {\r\n                        this.logger.log(LogLevel.Debug, \"Selecting transport '\" + HttpTransportType[transport] + \"'.\");\r\n                        try {\r\n                            return this.constructTransport(transport);\r\n                        }\r\n                        catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it does not support the requested transfer format '\" + TransferFormat[requestedTransferFormat] + \"'.\");\r\n                    return new Error(\"'\" + HttpTransportType[transport] + \"' does not support \" + TransferFormat[requestedTransferFormat] + \".\");\r\n                }\r\n            }\r\n            else {\r\n                this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it was disabled by the client.\");\r\n                return new Error(\"'\" + HttpTransportType[transport] + \"' is disabled by the client.\");\r\n            }\r\n        }\r\n    };\r\n    HttpConnection.prototype.isITransport = function (transport) {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    };\r\n    HttpConnection.prototype.stopConnection = function (error) {\r\n        this.logger.log(LogLevel.Debug, \"HttpConnection.stopConnection(\" + error + \") called while in state \" + this.connectionState + \".\");\r\n        this.transport = undefined;\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this.stopError || error;\r\n        this.stopError = undefined;\r\n        if (this.connectionState === \"Disconnected\" /* Disconnected */) {\r\n            this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is already in the disconnected state.\");\r\n            return;\r\n        }\r\n        if (this.connectionState === \"Connecting \" /* Connecting */) {\r\n            this.logger.log(LogLevel.Warning, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection hasn't yet left the in the connecting state.\");\r\n            return;\r\n        }\r\n        if (this.connectionState === \"Disconnecting\" /* Disconnecting */) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this.stopPromiseResolver();\r\n        }\r\n        if (error) {\r\n            this.logger.log(LogLevel.Error, \"Connection disconnected with error '\" + error + \"'.\");\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n        this.connectionId = undefined;\r\n        this.connectionState = \"Disconnected\" /* Disconnected */;\r\n        if (this.onclose && this.connectionStarted) {\r\n            this.connectionStarted = false;\r\n            try {\r\n                this.onclose(error);\r\n            }\r\n            catch (e) {\r\n                this.logger.log(LogLevel.Error, \"HttpConnection.onclose(\" + error + \") threw error '\" + e + \"'.\");\r\n            }\r\n        }\r\n    };\r\n    HttpConnection.prototype.resolveUrl = function (url) {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n        if (!Platform.isBrowser || !window.document) {\r\n            throw new Error(\"Cannot resolve '\" + url + \"'.\");\r\n        }\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative  path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        var aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n        this.logger.log(LogLevel.Information, \"Normalizing '\" + url + \"' to '\" + aTag.href + \"'.\");\r\n        return aTag.href;\r\n    };\r\n    HttpConnection.prototype.resolveNegotiateUrl = function (url) {\r\n        var index = url.indexOf(\"?\");\r\n        var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n        return negotiateUrl;\r\n    };\r\n    return HttpConnection;\r\n}());\r\nexport { HttpConnection };\r\nfunction transportMatches(requestedTransport, actualTransport) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\nvar TransportSendQueue = /** @class */ (function () {\r\n    function TransportSendQueue(transport) {\r\n        this.transport = transport;\r\n        this.buffer = [];\r\n        this.executing = true;\r\n        this.sendBufferedData = new PromiseSource();\r\n        this.transportResult = new PromiseSource();\r\n        this.sendLoopPromise = this.sendLoop();\r\n    }\r\n    TransportSendQueue.prototype.send = function (data) {\r\n        this.bufferData(data);\r\n        if (!this.transportResult) {\r\n            this.transportResult = new PromiseSource();\r\n        }\r\n        return this.transportResult.promise;\r\n    };\r\n    TransportSendQueue.prototype.stop = function () {\r\n        this.executing = false;\r\n        this.sendBufferedData.resolve();\r\n        return this.sendLoopPromise;\r\n    };\r\n    TransportSendQueue.prototype.bufferData = function (data) {\r\n        if (this.buffer.length && typeof (this.buffer[0]) !== typeof (data)) {\r\n            throw new Error(\"Expected data to be of type \" + typeof (this.buffer) + \" but was of type \" + typeof (data));\r\n        }\r\n        this.buffer.push(data);\r\n        this.sendBufferedData.resolve();\r\n    };\r\n    TransportSendQueue.prototype.sendLoop = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var transportResult, data, error_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!true) return [3 /*break*/, 6];\r\n                        return [4 /*yield*/, this.sendBufferedData.promise];\r\n                    case 1:\r\n                        _a.sent();\r\n                        if (!this.executing) {\r\n                            if (this.transportResult) {\r\n                                this.transportResult.reject(\"Connection stopped.\");\r\n                            }\r\n                            return [3 /*break*/, 6];\r\n                        }\r\n                        this.sendBufferedData = new PromiseSource();\r\n                        transportResult = this.transportResult;\r\n                        this.transportResult = undefined;\r\n                        data = typeof (this.buffer[0]) === \"string\" ?\r\n                            this.buffer.join(\"\") :\r\n                            TransportSendQueue.concatBuffers(this.buffer);\r\n                        this.buffer.length = 0;\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        return [4 /*yield*/, this.transport.send(data)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        transportResult.resolve();\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        error_1 = _a.sent();\r\n                        transportResult.reject(error_1);\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [3 /*break*/, 0];\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TransportSendQueue.concatBuffers = function (arrayBuffers) {\r\n        var totalLength = arrayBuffers.map(function (b) { return b.byteLength; }).reduce(function (a, b) { return a + b; });\r\n        var result = new Uint8Array(totalLength);\r\n        var offset = 0;\r\n        for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {\r\n            var item = arrayBuffers_1[_i];\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return result;\r\n    };\r\n    return TransportSendQueue;\r\n}());\r\nexport { TransportSendQueue };\r\nvar PromiseSource = /** @class */ (function () {\r\n    function PromiseSource() {\r\n        var _this = this;\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            var _a;\r\n            return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;\r\n        });\r\n    }\r\n    PromiseSource.prototype.resolve = function () {\r\n        this.resolver();\r\n    };\r\n    PromiseSource.prototype.reject = function (reason) {\r\n        this.rejecter(reason);\r\n    };\r\n    return PromiseSource;\r\n}());\r\n//# sourceMappingURL=HttpConnection.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg } from \"./Utils\";\r\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport var HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\r\n    /** The hub connection is connecting. */\r\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[\"Connected\"] = \"Connected\";\r\n    /** The hub connection is disconnecting. */\r\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\r\n    /** The hub connection is reconnecting. */\r\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\r\n})(HubConnectionState || (HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nvar HubConnection = /** @class */ (function () {\r\n    function HubConnection(connection, logger, protocol, reconnectPolicy) {\r\n        var _this = this;\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.reconnectPolicy = reconnectPolicy;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = function (data) { return _this.processIncomingData(data); };\r\n        this.connection.onclose = function (error) { return _this.connectionClosed(error); };\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.reconnectingCallbacks = [];\r\n        this.reconnectedCallbacks = [];\r\n        this.invocationId = 0;\r\n        this.receivedHandshakeResponse = false;\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n        this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    };\r\n    Object.defineProperty(HubConnection.prototype, \"state\", {\r\n        /** Indicates the state of the {@link HubConnection} to the server. */\r\n        get: function () {\r\n            return this.connectionState;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HubConnection.prototype, \"connectionId\", {\r\n        /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n         *  in the disconnected state or if the negotiation step was skipped.\r\n         */\r\n        get: function () {\r\n            return this.connection ? (this.connection.connectionId || null) : null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HubConnection.prototype, \"baseUrl\", {\r\n        /** Indicates the url of the {@link HubConnection} to the server. */\r\n        get: function () {\r\n            return this.connection.baseUrl || \"\";\r\n        },\r\n        /**\r\n         * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n         * Reconnecting states.\r\n         * @param {string} url The url to connect to.\r\n         */\r\n        set: function (url) {\r\n            if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\r\n                throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n            }\r\n            if (!url) {\r\n                throw new Error(\"The HubConnection url must be a valid url.\");\r\n            }\r\n            this.connection.baseUrl = url;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.start = function () {\r\n        this.startPromise = this.startWithStateTransitions();\r\n        return this.startPromise;\r\n    };\r\n    HubConnection.prototype.startWithStateTransitions = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (this.connectionState !== HubConnectionState.Disconnected) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"))];\r\n                        }\r\n                        this.connectionState = HubConnectionState.Connecting;\r\n                        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.startInternal()];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.connectionState = HubConnectionState.Connected;\r\n                        this.connectionStarted = true;\r\n                        this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        this.connectionState = HubConnectionState.Disconnected;\r\n                        this.logger.log(LogLevel.Debug, \"HubConnection failed to start successfully because of error '\" + e_1 + \"'.\");\r\n                        return [2 /*return*/, Promise.reject(e_1)];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.startInternal = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var handshakePromise, handshakeRequest, e_2;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.stopDuringStartError = undefined;\r\n                        this.receivedHandshakeResponse = false;\r\n                        handshakePromise = new Promise(function (resolve, reject) {\r\n                            _this.handshakeResolver = resolve;\r\n                            _this.handshakeRejecter = reject;\r\n                        });\r\n                        return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 5, , 7]);\r\n                        handshakeRequest = {\r\n                            protocol: this.protocol.name,\r\n                            version: this.protocol.version,\r\n                        };\r\n                        this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n                        return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\r\n                    case 3:\r\n                        _a.sent();\r\n                        this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\");\r\n                        // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n                        this.cleanupTimeout();\r\n                        this.resetTimeoutPeriod();\r\n                        this.resetKeepAliveInterval();\r\n                        return [4 /*yield*/, handshakePromise];\r\n                    case 4:\r\n                        _a.sent();\r\n                        // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n                        // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n                        // and the connection was closed.\r\n                        if (this.stopDuringStartError) {\r\n                            // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                            // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                            // will cause the calling continuation to get scheduled to run later.\r\n                            throw this.stopDuringStartError;\r\n                        }\r\n                        return [3 /*break*/, 7];\r\n                    case 5:\r\n                        e_2 = _a.sent();\r\n                        this.logger.log(LogLevel.Debug, \"Hub handshake failed with error '\" + e_2 + \"' during start(). Stopping HubConnection.\");\r\n                        this.cleanupTimeout();\r\n                        this.cleanupPingTimer();\r\n                        // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n                        // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n                        return [4 /*yield*/, this.connection.stop(e_2)];\r\n                    case 6:\r\n                        // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n                        // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n                        _a.sent();\r\n                        throw e_2;\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.stop = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var startPromise, e_3;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        startPromise = this.startPromise;\r\n                        this.stopPromise = this.stopInternal();\r\n                        return [4 /*yield*/, this.stopPromise];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        // Awaiting undefined continues immediately\r\n                        return [4 /*yield*/, startPromise];\r\n                    case 3:\r\n                        // Awaiting undefined continues immediately\r\n                        _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        e_3 = _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.stopInternal = function (error) {\r\n        if (this.connectionState === HubConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, \"Call to HubConnection.stop(\" + error + \") ignored because it is already in the disconnected state.\");\r\n            return Promise.resolve();\r\n        }\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\r\n            return this.stopPromise;\r\n        }\r\n        this.connectionState = HubConnectionState.Disconnecting;\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        if (this.reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n            clearTimeout(this.reconnectDelayHandle);\r\n            this.reconnectDelayHandle = undefined;\r\n            this.completeClose();\r\n            return Promise.resolve();\r\n        }\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    };\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    HubConnection.prototype.stream = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\r\n        var promiseQueue;\r\n        var subject = new Subject();\r\n        subject.cancelCallback = function () {\r\n            var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(function () {\r\n                return _this.sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n        this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n            .catch(function (e) {\r\n            subject.error(e);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        this.launchStreams(streams, promiseQueue);\r\n        return subject;\r\n    };\r\n    HubConnection.prototype.sendMessage = function (message) {\r\n        this.resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    };\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    HubConnection.prototype.sendWithProtocol = function (message) {\r\n        return this.sendMessage(this.protocol.writeMessage(message));\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.send = function (methodName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\r\n        this.launchStreams(streams, sendPromise);\r\n        return sendPromise;\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    HubConnection.prototype.invoke = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\r\n        var p = new Promise(function (resolve, reject) {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\r\n                    }\r\n                }\r\n            };\r\n            var promiseQueue = _this.sendWithProtocol(invocationDescriptor)\r\n                .catch(function (e) {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete _this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n            _this.launchStreams(streams, promiseQueue);\r\n        });\r\n        return p;\r\n    };\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    HubConnection.prototype.on = function (methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this.methods[methodName].push(newMethod);\r\n    };\r\n    HubConnection.prototype.off = function (methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        var handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            var removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this.methods[methodName];\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    HubConnection.prototype.onclose = function (callback) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    HubConnection.prototype.onreconnecting = function (callback) {\r\n        if (callback) {\r\n            this.reconnectingCallbacks.push(callback);\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    HubConnection.prototype.onreconnected = function (callback) {\r\n        if (callback) {\r\n            this.reconnectedCallbacks.push(callback);\r\n        }\r\n    };\r\n    HubConnection.prototype.processIncomingData = function (data) {\r\n        this.cleanupTimeout();\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            var messages = this.protocol.parseMessages(data, this.logger);\r\n            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n                var message = messages_1[_i];\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        var callback = this.callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        // We don't want to wait on the stop itself.\r\n                        this.stopPromise = this.stopInternal(message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined);\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this.resetTimeoutPeriod();\r\n    };\r\n    HubConnection.prototype.processHandshakeResponse = function (data) {\r\n        var _a;\r\n        var responseMessage;\r\n        var remainingData;\r\n        try {\r\n            _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\r\n        }\r\n        catch (e) {\r\n            var message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            var message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this.handshakeResolver();\r\n        return remainingData;\r\n    };\r\n    HubConnection.prototype.resetKeepAliveInterval = function () {\r\n        var _this = this;\r\n        this.cleanupPingTimer();\r\n        this.pingServerHandle = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        _a = _b.sent();\r\n                        // We don't care about the error. It should be seen elsewhere in the client.\r\n                        // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                        this.cleanupPingTimer();\r\n                        return [3 /*break*/, 4];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); }, this.keepAliveIntervalInMilliseconds);\r\n    };\r\n    HubConnection.prototype.resetTimeoutPeriod = function () {\r\n        var _this = this;\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);\r\n        }\r\n    };\r\n    HubConnection.prototype.serverTimeout = function () {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    };\r\n    HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\r\n        var _this = this;\r\n        var methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });\r\n            }\r\n            catch (e) {\r\n                this.logger.log(LogLevel.Error, \"A callback for the method \" + invocationMessage.target.toLowerCase() + \" threw error '\" + e + \"'.\");\r\n            }\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                var message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n                // We don't want to wait on the stop itself.\r\n                this.stopPromise = this.stopInternal(new Error(message));\r\n            }\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\r\n        }\r\n    };\r\n    HubConnection.prototype.connectionClosed = function (error) {\r\n        this.logger.log(LogLevel.Debug, \"HubConnection.connectionClosed(\" + error + \") called while in state \" + this.connectionState + \".\");\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this.handshakeResolver) {\r\n            this.handshakeResolver();\r\n        }\r\n        this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.completeClose(error);\r\n        }\r\n        else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.reconnect(error);\r\n        }\r\n        else if (this.connectionState === HubConnectionState.Connected) {\r\n            this.completeClose(error);\r\n        }\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    };\r\n    HubConnection.prototype.completeClose = function (error) {\r\n        var _this = this;\r\n        if (this.connectionStarted) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.connectionStarted = false;\r\n            try {\r\n                this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n            }\r\n            catch (e) {\r\n                this.logger.log(LogLevel.Error, \"An onclose callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\r\n            }\r\n        }\r\n    };\r\n    HubConnection.prototype.reconnect = function (error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        reconnectStartTime = Date.now();\r\n                        previousReconnectAttempts = 0;\r\n                        retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n                        nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n                        if (nextRetryDelay === null) {\r\n                            this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n                            this.completeClose(error);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        this.connectionState = HubConnectionState.Reconnecting;\r\n                        if (error) {\r\n                            this.logger.log(LogLevel.Information, \"Connection reconnecting because of error '\" + error + \"'.\");\r\n                        }\r\n                        else {\r\n                            this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n                        }\r\n                        if (this.onreconnecting) {\r\n                            try {\r\n                                this.reconnectingCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n                            }\r\n                            catch (e) {\r\n                                this.logger.log(LogLevel.Error, \"An onreconnecting callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\r\n                            }\r\n                            // Exit early if an onreconnecting callback called connection.stop().\r\n                            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                                return [2 /*return*/];\r\n                            }\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(nextRetryDelay !== null)) return [3 /*break*/, 7];\r\n                        this.logger.log(LogLevel.Information, \"Reconnect attempt number \" + previousReconnectAttempts + \" will start in \" + nextRetryDelay + \" ms.\");\r\n                        return [4 /*yield*/, new Promise(function (resolve) {\r\n                                _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\r\n                            })];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.reconnectDelayHandle = undefined;\r\n                        if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                            this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                            return [2 /*return*/];\r\n                        }\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        _a.trys.push([3, 5, , 6]);\r\n                        return [4 /*yield*/, this.startInternal()];\r\n                    case 4:\r\n                        _a.sent();\r\n                        this.connectionState = HubConnectionState.Connected;\r\n                        this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n                        if (this.onreconnected) {\r\n                            try {\r\n                                this.reconnectedCallbacks.forEach(function (c) { return c.apply(_this, [_this.connection.connectionId]); });\r\n                            }\r\n                            catch (e) {\r\n                                this.logger.log(LogLevel.Error, \"An onreconnected callback called with connectionId '\" + this.connection.connectionId + \"; threw error '\" + e + \"'.\");\r\n                            }\r\n                        }\r\n                        return [2 /*return*/];\r\n                    case 5:\r\n                        e_4 = _a.sent();\r\n                        this.logger.log(LogLevel.Information, \"Reconnect attempt failed because of error '\" + e_4 + \"'.\");\r\n                        if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                            this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect attempt. Done reconnecting.\");\r\n                            return [2 /*return*/];\r\n                        }\r\n                        retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());\r\n                        nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n                        return [3 /*break*/, 6];\r\n                    case 6: return [3 /*break*/, 1];\r\n                    case 7:\r\n                        this.logger.log(LogLevel.Information, \"Reconnect retries have been exhausted after \" + (Date.now() - reconnectStartTime) + \" ms and \" + previousReconnectAttempts + \" failed attempts. Connection disconnecting.\");\r\n                        this.completeClose();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {\r\n        try {\r\n            return this.reconnectPolicy.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds: elapsedMilliseconds,\r\n                previousRetryCount: previousRetryCount,\r\n                retryReason: retryReason,\r\n            });\r\n        }\r\n        catch (e) {\r\n            this.logger.log(LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\" + previousRetryCount + \", \" + elapsedMilliseconds + \") threw error '\" + e + \"'.\");\r\n            return null;\r\n        }\r\n    };\r\n    HubConnection.prototype.cancelCallbacksWithError = function (error) {\r\n        var callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach(function (key) {\r\n            var callback = callbacks[key];\r\n            callback(null, error);\r\n        });\r\n    };\r\n    HubConnection.prototype.cleanupPingTimer = function () {\r\n        if (this.pingServerHandle) {\r\n            clearTimeout(this.pingServerHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.cleanupTimeout = function () {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {\r\n        if (nonblocking) {\r\n            return {\r\n                arguments: args,\r\n                streamIds: streamIds,\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n        else {\r\n            var invocationId = this.invocationId;\r\n            this.invocationId++;\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds: streamIds,\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n    };\r\n    HubConnection.prototype.launchStreams = function (streams, promiseQueue) {\r\n        var _this = this;\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n        var _loop_1 = function (streamId) {\r\n            streams[streamId].subscribe({\r\n                complete: function () {\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId)); });\r\n                },\r\n                error: function (err) {\r\n                    var message;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    }\r\n                    else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    }\r\n                    else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message)); });\r\n                },\r\n                next: function (item) {\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item)); });\r\n                },\r\n            });\r\n        };\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // tslint:disable-next-line:forin\r\n        for (var streamId in streams) {\r\n            _loop_1(streamId);\r\n        }\r\n    };\r\n    HubConnection.prototype.replaceStreamingParams = function (args) {\r\n        var streams = [];\r\n        var streamIds = [];\r\n        for (var i = 0; i < args.length; i++) {\r\n            var argument = args[i];\r\n            if (this.isObservable(argument)) {\r\n                var streamId = this.invocationId;\r\n                this.invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n        return [streams, streamIds];\r\n    };\r\n    HubConnection.prototype.isObservable = function (arg) {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    };\r\n    HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {\r\n        var invocationId = this.invocationId;\r\n        this.invocationId++;\r\n        return {\r\n            arguments: args,\r\n            invocationId: invocationId.toString(),\r\n            streamIds: streamIds,\r\n            target: methodName,\r\n            type: MessageType.StreamInvocation,\r\n        };\r\n    };\r\n    HubConnection.prototype.createCancelInvocation = function (id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    };\r\n    HubConnection.prototype.createStreamItemMessage = function (id, item) {\r\n        return {\r\n            invocationId: id,\r\n            item: item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    };\r\n    HubConnection.prototype.createCompletionMessage = function (id, error, result) {\r\n        if (error) {\r\n            return {\r\n                error: error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n        return {\r\n            invocationId: id,\r\n            result: result,\r\n            type: MessageType.Completion,\r\n        };\r\n    };\r\n    return HubConnection;\r\n}());\r\nexport { HubConnection };\r\n//# sourceMappingURL=HubConnection.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\n// tslint:disable:object-literal-sort-keys\r\nvar LogLevelNameMapping = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\nfunction parseLogLevel(name) {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    var mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    }\r\n    else {\r\n        throw new Error(\"Unknown log level: \" + name);\r\n    }\r\n}\r\n/** A builder for configuring {@link @aspnet/signalr.HubConnection} instances. */\r\nvar HubConnectionBuilder = /** @class */ (function () {\r\n    function HubConnectionBuilder() {\r\n    }\r\n    HubConnectionBuilder.prototype.configureLogging = function (logging) {\r\n        Arg.isRequired(logging, \"logging\");\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        }\r\n        else if (typeof logging === \"string\") {\r\n            var logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        }\r\n        else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n        return this;\r\n    };\r\n    HubConnectionBuilder.prototype.withUrl = function (url, transportTypeOrOptions) {\r\n        Arg.isRequired(url, \"url\");\r\n        this.url = url;\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = __assign({}, this.httpConnectionOptions, transportTypeOrOptions);\r\n        }\r\n        else {\r\n            this.httpConnectionOptions = __assign({}, this.httpConnectionOptions, { transport: transportTypeOrOptions });\r\n        }\r\n        return this;\r\n    };\r\n    /** Configures the {@link @aspnet/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @aspnet/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    HubConnectionBuilder.prototype.withHubProtocol = function (protocol) {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.protocol = protocol;\r\n        return this;\r\n    };\r\n    HubConnectionBuilder.prototype.withAutomaticReconnect = function (retryDelaysOrReconnectPolicy) {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        }\r\n        else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        }\r\n        else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n        return this;\r\n    };\r\n    /** Creates a {@link @aspnet/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @aspnet/signalr.HubConnection}.\r\n     */\r\n    HubConnectionBuilder.prototype.build = function () {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        var httpConnectionOptions = this.httpConnectionOptions || {};\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        var connection = new HttpConnection(this.url, httpConnectionOptions);\r\n        return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy);\r\n    };\r\n    return HubConnectionBuilder;\r\n}());\r\nexport { HubConnectionBuilder };\r\nfunction isLogger(logger) {\r\n    return logger.log !== undefined;\r\n}\r\n//# sourceMappingURL=HubConnectionBuilder.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n/** Defines the type of a Hub Message. */\r\nexport var MessageType;\r\n(function (MessageType) {\r\n    /** Indicates the message is an Invocation message and implements the {@link @aspnet/signalr.InvocationMessage} interface. */\r\n    MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\r\n    /** Indicates the message is a StreamItem message and implements the {@link @aspnet/signalr.StreamItemMessage} interface. */\r\n    MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\r\n    /** Indicates the message is a Completion message and implements the {@link @aspnet/signalr.CompletionMessage} interface. */\r\n    MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @aspnet/signalr.StreamInvocationMessage} interface. */\r\n    MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @aspnet/signalr.CancelInvocationMessage} interface. */\r\n    MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\r\n    /** Indicates the message is a Ping message and implements the {@link @aspnet/signalr.PingMessage} interface. */\r\n    MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\r\n    /** Indicates the message is a Close message and implements the {@link @aspnet/signalr.CloseMessage} interface. */\r\n    MessageType[MessageType[\"Close\"] = 7] = \"Close\";\r\n})(MessageType || (MessageType = {}));\r\n//# sourceMappingURL=IHubProtocol.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport var LogLevel;\r\n(function (LogLevel) {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\r\n    /** Log level for low severity diagnostic messages. */\r\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\r\n    /** Log level for informational diagnostic messages. */\r\n    LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\r\n})(LogLevel || (LogLevel = {}));\r\n//# sourceMappingURL=ILogger.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport var HttpTransportType;\r\n(function (HttpTransportType) {\r\n    /** Specifies no transport preference. */\r\n    HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\r\n    /** Specifies the WebSockets transport. */\r\n    HttpTransportType[HttpTransportType[\"WebSockets\"] = 1] = \"WebSockets\";\r\n    /** Specifies the Server-Sent Events transport. */\r\n    HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\r\n    /** Specifies the Long Polling transport. */\r\n    HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\r\n})(HttpTransportType || (HttpTransportType = {}));\r\n/** Specifies the transfer format for a connection. */\r\nexport var TransferFormat;\r\n(function (TransferFormat) {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\r\n})(TransferFormat || (TransferFormat = {}));\r\n//# sourceMappingURL=ITransport.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nvar JSON_HUB_PROTOCOL_NAME = \"json\";\r\n/** Implements the JSON Hub Protocol. */\r\nvar JsonHubProtocol = /** @class */ (function () {\r\n    function JsonHubProtocol() {\r\n        /** @inheritDoc */\r\n        this.name = JSON_HUB_PROTOCOL_NAME;\r\n        /** @inheritDoc */\r\n        this.version = 1;\r\n        /** @inheritDoc */\r\n        this.transferFormat = TransferFormat.Text;\r\n    }\r\n    /** Creates an array of {@link @aspnet/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    JsonHubProtocol.prototype.parseMessages = function (input, logger) {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n        if (!input) {\r\n            return [];\r\n        }\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n        // Parse the messages\r\n        var messages = TextMessageFormat.parse(input);\r\n        var hubMessages = [];\r\n        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n            var message = messages_1[_i];\r\n            var parsedMessage = JSON.parse(message);\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this.isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this.isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this.isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n        return hubMessages;\r\n    };\r\n    /** Writes the specified {@link @aspnet/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    JsonHubProtocol.prototype.writeMessage = function (message) {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    };\r\n    JsonHubProtocol.prototype.isInvocationMessage = function (message) {\r\n        this.assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n        if (message.invocationId !== undefined) {\r\n            this.assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    };\r\n    JsonHubProtocol.prototype.isStreamItemMessage = function (message) {\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    };\r\n    JsonHubProtocol.prototype.isCompletionMessage = function (message) {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n        if (!message.result && message.error) {\r\n            this.assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n        this.assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    };\r\n    JsonHubProtocol.prototype.assertNotEmptyString = function (value, errorMessage) {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    };\r\n    return JsonHubProtocol;\r\n}());\r\nexport { JsonHubProtocol };\r\n//# sourceMappingURL=JsonHubProtocol.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n/** A logger that does nothing when log messages are sent to it. */\r\nvar NullLogger = /** @class */ (function () {\r\n    function NullLogger() {\r\n    }\r\n    /** @inheritDoc */\r\n    // tslint:disable-next-line\r\n    NullLogger.prototype.log = function (_logLevel, _message) {\r\n    };\r\n    /** The singleton instance of the {@link @aspnet/signalr.NullLogger}. */\r\n    NullLogger.instance = new NullLogger();\r\n    return NullLogger;\r\n}());\r\nexport { NullLogger };\r\n//# sourceMappingURL=Loggers.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, sendMessage } from \"./Utils\";\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nvar LongPollingTransport = /** @class */ (function () {\r\n    function LongPollingTransport(httpClient, accessTokenFactory, logger, logMessageContent) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logger = logger;\r\n        this.pollAbort = new AbortController();\r\n        this.logMessageContent = logMessageContent;\r\n        this.running = false;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    Object.defineProperty(LongPollingTransport.prototype, \"pollAborted\", {\r\n        // This is an internal type, not exported from 'index' so this is really just internal.\r\n        get: function () {\r\n            return this.pollAbort.aborted;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    LongPollingTransport.prototype.connect = function (url, transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var pollOptions, token, pollUrl, response;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        Arg.isRequired(url, \"url\");\r\n                        Arg.isRequired(transferFormat, \"transferFormat\");\r\n                        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n                        this.url = url;\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n                        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n                        if (transferFormat === TransferFormat.Binary &&\r\n                            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n                            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n                        }\r\n                        pollOptions = {\r\n                            abortSignal: this.pollAbort.signal,\r\n                            headers: {},\r\n                            timeout: 100000,\r\n                        };\r\n                        if (transferFormat === TransferFormat.Binary) {\r\n                            pollOptions.responseType = \"arraybuffer\";\r\n                        }\r\n                        return [4 /*yield*/, this.getAccessToken()];\r\n                    case 1:\r\n                        token = _a.sent();\r\n                        this.updateHeaderToken(pollOptions, token);\r\n                        pollUrl = url + \"&_=\" + Date.now();\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) polling: \" + pollUrl + \".\");\r\n                        return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];\r\n                    case 2:\r\n                        response = _a.sent();\r\n                        if (response.statusCode !== 200) {\r\n                            this.logger.log(LogLevel.Error, \"(LongPolling transport) Unexpected response code: \" + response.statusCode + \".\");\r\n                            // Mark running as false so that the poll immediately ends and runs the close logic\r\n                            this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                            this.running = false;\r\n                        }\r\n                        else {\r\n                            this.running = true;\r\n                        }\r\n                        this.receiving = this.poll(this.url, pollOptions);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    LongPollingTransport.prototype.getAccessToken = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this.accessTokenFactory) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.accessTokenFactory()];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                    case 2: return [2 /*return*/, null];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    LongPollingTransport.prototype.updateHeaderToken = function (request, token) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (token) {\r\n            // tslint:disable-next-line:no-string-literal\r\n            request.headers[\"Authorization\"] = \"Bearer \" + token;\r\n            return;\r\n        }\r\n        // tslint:disable-next-line:no-string-literal\r\n        if (request.headers[\"Authorization\"]) {\r\n            // tslint:disable-next-line:no-string-literal\r\n            delete request.headers[\"Authorization\"];\r\n        }\r\n    };\r\n    LongPollingTransport.prototype.poll = function (url, pollOptions) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var token, pollUrl, response, e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, , 8, 9]);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!this.running) return [3 /*break*/, 7];\r\n                        return [4 /*yield*/, this.getAccessToken()];\r\n                    case 2:\r\n                        token = _a.sent();\r\n                        this.updateHeaderToken(pollOptions, token);\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        _a.trys.push([3, 5, , 6]);\r\n                        pollUrl = url + \"&_=\" + Date.now();\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) polling: \" + pollUrl + \".\");\r\n                        return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];\r\n                    case 4:\r\n                        response = _a.sent();\r\n                        if (response.statusCode === 204) {\r\n                            this.logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n                            this.running = false;\r\n                        }\r\n                        else if (response.statusCode !== 200) {\r\n                            this.logger.log(LogLevel.Error, \"(LongPolling transport) Unexpected response code: \" + response.statusCode + \".\");\r\n                            // Unexpected status code\r\n                            this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                            this.running = false;\r\n                        }\r\n                        else {\r\n                            // Process the response\r\n                            if (response.content) {\r\n                                this.logger.log(LogLevel.Trace, \"(LongPolling transport) data received. \" + getDataDetail(response.content, this.logMessageContent) + \".\");\r\n                                if (this.onreceive) {\r\n                                    this.onreceive(response.content);\r\n                                }\r\n                            }\r\n                            else {\r\n                                // This is another way timeout manifest.\r\n                                this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                            }\r\n                        }\r\n                        return [3 /*break*/, 6];\r\n                    case 5:\r\n                        e_1 = _a.sent();\r\n                        if (!this.running) {\r\n                            // Log but disregard errors that occur after stopping\r\n                            this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll errored after shutdown: \" + e_1.message);\r\n                        }\r\n                        else {\r\n                            if (e_1 instanceof TimeoutError) {\r\n                                // Ignore timeouts and reissue the poll.\r\n                                this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                            }\r\n                            else {\r\n                                // Close the connection with the error as the result.\r\n                                this.closeError = e_1;\r\n                                this.running = false;\r\n                            }\r\n                        }\r\n                        return [3 /*break*/, 6];\r\n                    case 6: return [3 /*break*/, 1];\r\n                    case 7: return [3 /*break*/, 9];\r\n                    case 8:\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n                        // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n                        // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n                        if (!this.pollAborted) {\r\n                            this.raiseOnClose();\r\n                        }\r\n                        return [7 /*endfinally*/];\r\n                    case 9: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    LongPollingTransport.prototype.send = function (data) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                if (!this.running) {\r\n                    return [2 /*return*/, Promise.reject(new Error(\"Cannot send until the transport is connected\"))];\r\n                }\r\n                return [2 /*return*/, sendMessage(this.logger, \"LongPolling\", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];\r\n            });\r\n        });\r\n    };\r\n    LongPollingTransport.prototype.stop = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var deleteOptions, token;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n                        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n                        this.running = false;\r\n                        this.pollAbort.abort();\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, , 5, 6]);\r\n                        return [4 /*yield*/, this.receiving];\r\n                    case 2:\r\n                        _a.sent();\r\n                        // Send DELETE to clean up long polling on the server\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) sending DELETE request to \" + this.url + \".\");\r\n                        deleteOptions = {\r\n                            headers: {},\r\n                        };\r\n                        return [4 /*yield*/, this.getAccessToken()];\r\n                    case 3:\r\n                        token = _a.sent();\r\n                        this.updateHeaderToken(deleteOptions, token);\r\n                        return [4 /*yield*/, this.httpClient.delete(this.url, deleteOptions)];\r\n                    case 4:\r\n                        _a.sent();\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\r\n                        return [3 /*break*/, 6];\r\n                    case 5:\r\n                        this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n                        // Raise close event here instead of in polling\r\n                        // It needs to happen after the DELETE request is sent\r\n                        this.raiseOnClose();\r\n                        return [7 /*endfinally*/];\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    LongPollingTransport.prototype.raiseOnClose = function () {\r\n        if (this.onclose) {\r\n            var logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this.closeError) {\r\n                logMessage += \" Error: \" + this.closeError;\r\n            }\r\n            this.logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this.closeError);\r\n        }\r\n    };\r\n    return LongPollingTransport;\r\n}());\r\nexport { LongPollingTransport };\r\n//# sourceMappingURL=LongPollingTransport.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\nvar requestModule;\r\nif (typeof XMLHttpRequest === \"undefined\") {\r\n    // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n    // @ts-ignore: TS doesn't know about these names\r\n    var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n    requestModule = requireFunc(\"request\");\r\n}\r\nvar NodeHttpClient = /** @class */ (function (_super) {\r\n    __extends(NodeHttpClient, _super);\r\n    function NodeHttpClient(logger) {\r\n        var _this = _super.call(this) || this;\r\n        if (typeof requestModule === \"undefined\") {\r\n            throw new Error(\"The 'request' module could not be loaded.\");\r\n        }\r\n        _this.logger = logger;\r\n        _this.cookieJar = requestModule.jar();\r\n        _this.request = requestModule.defaults({ jar: _this.cookieJar });\r\n        return _this;\r\n    }\r\n    NodeHttpClient.prototype.send = function (httpRequest) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            var requestBody;\r\n            if (isArrayBuffer(httpRequest.content)) {\r\n                requestBody = Buffer.from(httpRequest.content);\r\n            }\r\n            else {\r\n                requestBody = httpRequest.content || \"\";\r\n            }\r\n            var currentRequest = _this.request(httpRequest.url, {\r\n                body: requestBody,\r\n                // If binary is expected 'null' should be used, otherwise for text 'utf8'\r\n                encoding: httpRequest.responseType === \"arraybuffer\" ? null : \"utf8\",\r\n                headers: __assign({ \r\n                    // Tell auth middleware to 401 instead of redirecting\r\n                    \"X-Requested-With\": \"XMLHttpRequest\" }, httpRequest.headers),\r\n                method: httpRequest.method,\r\n                timeout: httpRequest.timeout,\r\n            }, function (error, response, body) {\r\n                if (httpRequest.abortSignal) {\r\n                    httpRequest.abortSignal.onabort = null;\r\n                }\r\n                if (error) {\r\n                    if (error.code === \"ETIMEDOUT\") {\r\n                        _this.logger.log(LogLevel.Warning, \"Timeout from HTTP request.\");\r\n                        reject(new TimeoutError());\r\n                    }\r\n                    _this.logger.log(LogLevel.Warning, \"Error from HTTP request. \" + error);\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                if (response.statusCode >= 200 && response.statusCode < 300) {\r\n                    resolve(new HttpResponse(response.statusCode, response.statusMessage || \"\", body));\r\n                }\r\n                else {\r\n                    reject(new HttpError(response.statusMessage || \"\", response.statusCode || 0));\r\n                }\r\n            });\r\n            if (httpRequest.abortSignal) {\r\n                httpRequest.abortSignal.onabort = function () {\r\n                    currentRequest.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n        });\r\n    };\r\n    NodeHttpClient.prototype.getCookieString = function (url) {\r\n        return this.cookieJar.getCookieString(url);\r\n    };\r\n    return NodeHttpClient;\r\n}(HttpClient));\r\nexport { NodeHttpClient };\r\n//# sourceMappingURL=NodeHttpClient.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nvar ServerSentEventsTransport = /** @class */ (function () {\r\n    function ServerSentEventsTransport(httpClient, accessTokenFactory, logger, logMessageContent, eventSourceConstructor) {\r\n        this.httpClient = httpClient;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logger = logger;\r\n        this.logMessageContent = logMessageContent;\r\n        this.eventSourceConstructor = eventSourceConstructor;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    ServerSentEventsTransport.prototype.connect = function (url, transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var token;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        Arg.isRequired(url, \"url\");\r\n                        Arg.isRequired(transferFormat, \"transferFormat\");\r\n                        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n                        this.logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n                        // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\r\n                        this.url = url;\r\n                        if (!this.accessTokenFactory) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.accessTokenFactory()];\r\n                    case 1:\r\n                        token = _a.sent();\r\n                        if (token) {\r\n                            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + (\"access_token=\" + encodeURIComponent(token));\r\n                        }\r\n                        _a.label = 2;\r\n                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                            var opened = false;\r\n                            if (transferFormat !== TransferFormat.Text) {\r\n                                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                                return;\r\n                            }\r\n                            var eventSource;\r\n                            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                                eventSource = new _this.eventSourceConstructor(url, { withCredentials: true });\r\n                            }\r\n                            else {\r\n                                // Non-browser passes cookies via the dictionary\r\n                                var cookies = _this.httpClient.getCookieString(url);\r\n                                eventSource = new _this.eventSourceConstructor(url, { withCredentials: true, headers: { Cookie: cookies } });\r\n                            }\r\n                            try {\r\n                                eventSource.onmessage = function (e) {\r\n                                    if (_this.onreceive) {\r\n                                        try {\r\n                                            _this.logger.log(LogLevel.Trace, \"(SSE transport) data received. \" + getDataDetail(e.data, _this.logMessageContent) + \".\");\r\n                                            _this.onreceive(e.data);\r\n                                        }\r\n                                        catch (error) {\r\n                                            _this.close(error);\r\n                                            return;\r\n                                        }\r\n                                    }\r\n                                };\r\n                                eventSource.onerror = function (e) {\r\n                                    var error = new Error(e.data || \"Error occurred\");\r\n                                    if (opened) {\r\n                                        _this.close(error);\r\n                                    }\r\n                                    else {\r\n                                        reject(error);\r\n                                    }\r\n                                };\r\n                                eventSource.onopen = function () {\r\n                                    _this.logger.log(LogLevel.Information, \"SSE connected to \" + _this.url);\r\n                                    _this.eventSource = eventSource;\r\n                                    opened = true;\r\n                                    resolve();\r\n                                };\r\n                            }\r\n                            catch (e) {\r\n                                reject(e);\r\n                                return;\r\n                            }\r\n                        })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ServerSentEventsTransport.prototype.send = function (data) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                if (!this.eventSource) {\r\n                    return [2 /*return*/, Promise.reject(new Error(\"Cannot send until the transport is connected\"))];\r\n                }\r\n                return [2 /*return*/, sendMessage(this.logger, \"SSE\", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];\r\n            });\r\n        });\r\n    };\r\n    ServerSentEventsTransport.prototype.stop = function () {\r\n        this.close();\r\n        return Promise.resolve();\r\n    };\r\n    ServerSentEventsTransport.prototype.close = function (e) {\r\n        if (this.eventSource) {\r\n            this.eventSource.close();\r\n            this.eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    };\r\n    return ServerSentEventsTransport;\r\n}());\r\nexport { ServerSentEventsTransport };\r\n//# sourceMappingURL=ServerSentEventsTransport.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nimport { SubjectSubscription } from \"./Utils\";\r\n/** Stream implementation to stream items to the server. */\r\nvar Subject = /** @class */ (function () {\r\n    function Subject() {\r\n        this.observers = [];\r\n    }\r\n    Subject.prototype.next = function (item) {\r\n        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\r\n            var observer = _a[_i];\r\n            observer.next(item);\r\n        }\r\n    };\r\n    Subject.prototype.error = function (err) {\r\n        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\r\n            var observer = _a[_i];\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    };\r\n    Subject.prototype.complete = function () {\r\n        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {\r\n            var observer = _a[_i];\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    };\r\n    Subject.prototype.subscribe = function (observer) {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    };\r\n    return Subject;\r\n}());\r\nexport { Subject };\r\n//# sourceMappingURL=Subject.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// Not exported from index\r\n/** @private */\r\nvar TextMessageFormat = /** @class */ (function () {\r\n    function TextMessageFormat() {\r\n    }\r\n    TextMessageFormat.write = function (output) {\r\n        return \"\" + output + TextMessageFormat.RecordSeparator;\r\n    };\r\n    TextMessageFormat.parse = function (input) {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n        var messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    };\r\n    TextMessageFormat.RecordSeparatorCode = 0x1e;\r\n    TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n    return TextMessageFormat;\r\n}());\r\nexport { TextMessageFormat };\r\n//# sourceMappingURL=TextMessageFormat.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\n/** @private */\r\nvar Arg = /** @class */ (function () {\r\n    function Arg() {\r\n    }\r\n    Arg.isRequired = function (val, name) {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(\"The '\" + name + \"' argument is required.\");\r\n        }\r\n    };\r\n    Arg.isIn = function (val, values, name) {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(\"Unknown \" + name + \" value: \" + val + \".\");\r\n        }\r\n    };\r\n    return Arg;\r\n}());\r\nexport { Arg };\r\n/** @private */\r\nvar Platform = /** @class */ (function () {\r\n    function Platform() {\r\n    }\r\n    Object.defineProperty(Platform, \"isBrowser\", {\r\n        get: function () {\r\n            return typeof window === \"object\";\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Platform, \"isWebWorker\", {\r\n        get: function () {\r\n            return typeof self === \"object\" && \"importScripts\" in self;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Platform, \"isNode\", {\r\n        get: function () {\r\n            return !this.isBrowser && !this.isWebWorker;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Platform;\r\n}());\r\nexport { Platform };\r\n/** @private */\r\nexport function getDataDetail(data, includeContent) {\r\n    var detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = \"Binary data of length \" + data.byteLength;\r\n        if (includeContent) {\r\n            detail += \". Content: '\" + formatArrayBuffer(data) + \"'\";\r\n        }\r\n    }\r\n    else if (typeof data === \"string\") {\r\n        detail = \"String data of length \" + data.length;\r\n        if (includeContent) {\r\n            detail += \". Content: '\" + data + \"'\";\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n/** @private */\r\nexport function formatArrayBuffer(data) {\r\n    var view = new Uint8Array(data);\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    var str = \"\";\r\n    view.forEach(function (num) {\r\n        var pad = num < 16 ? \"0\" : \"\";\r\n        str += \"0x\" + pad + num.toString(16) + \" \";\r\n    });\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val) {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n/** @private */\r\nexport function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _a, headers, token, responseType, response;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    if (!accessTokenFactory) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, accessTokenFactory()];\r\n                case 1:\r\n                    token = _b.sent();\r\n                    if (token) {\r\n                        headers = (_a = {},\r\n                            _a[\"Authorization\"] = \"Bearer \" + token,\r\n                            _a);\r\n                    }\r\n                    _b.label = 2;\r\n                case 2:\r\n                    logger.log(LogLevel.Trace, \"(\" + transportName + \" transport) sending data. \" + getDataDetail(content, logMessageContent) + \".\");\r\n                    responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n                    return [4 /*yield*/, httpClient.post(url, {\r\n                            content: content,\r\n                            headers: headers,\r\n                            responseType: responseType,\r\n                        })];\r\n                case 3:\r\n                    response = _b.sent();\r\n                    logger.log(LogLevel.Trace, \"(\" + transportName + \" transport) request complete. Response status: \" + response.statusCode + \".\");\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n/** @private */\r\nexport function createLogger(logger) {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n    if (logger.log) {\r\n        return logger;\r\n    }\r\n    return new ConsoleLogger(logger);\r\n}\r\n/** @private */\r\nvar SubjectSubscription = /** @class */ (function () {\r\n    function SubjectSubscription(subject, observer) {\r\n        this.subject = subject;\r\n        this.observer = observer;\r\n    }\r\n    SubjectSubscription.prototype.dispose = function () {\r\n        var index = this.subject.observers.indexOf(this.observer);\r\n        if (index > -1) {\r\n            this.subject.observers.splice(index, 1);\r\n        }\r\n        if (this.subject.observers.length === 0 && this.subject.cancelCallback) {\r\n            this.subject.cancelCallback().catch(function (_) { });\r\n        }\r\n    };\r\n    return SubjectSubscription;\r\n}());\r\nexport { SubjectSubscription };\r\n/** @private */\r\nvar ConsoleLogger = /** @class */ (function () {\r\n    function ConsoleLogger(minimumLogLevel) {\r\n        this.minimumLogLevel = minimumLogLevel;\r\n        this.outputConsole = console;\r\n    }\r\n    ConsoleLogger.prototype.log = function (logLevel, message) {\r\n        if (logLevel >= this.minimumLogLevel) {\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.outputConsole.error(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.outputConsole.warn(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.outputConsole.info(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.outputConsole.log(\"[\" + new Date().toISOString() + \"] \" + LogLevel[logLevel] + \": \" + message);\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    return ConsoleLogger;\r\n}());\r\nexport { ConsoleLogger };\r\n//# sourceMappingURL=Utils.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, Platform } from \"./Utils\";\r\n/** @private */\r\nvar WebSocketTransport = /** @class */ (function () {\r\n    function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor) {\r\n        this.logger = logger;\r\n        this.accessTokenFactory = accessTokenFactory;\r\n        this.logMessageContent = logMessageContent;\r\n        this.webSocketConstructor = webSocketConstructor;\r\n        this.httpClient = httpClient;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    WebSocketTransport.prototype.connect = function (url, transferFormat) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var token;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        Arg.isRequired(url, \"url\");\r\n                        Arg.isRequired(transferFormat, \"transferFormat\");\r\n                        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n                        this.logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n                        if (!this.accessTokenFactory) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.accessTokenFactory()];\r\n                    case 1:\r\n                        token = _a.sent();\r\n                        if (token) {\r\n                            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + (\"access_token=\" + encodeURIComponent(token));\r\n                        }\r\n                        _a.label = 2;\r\n                    case 2: return [2 /*return*/, new Promise(function (resolve, reject) {\r\n                            url = url.replace(/^http/, \"ws\");\r\n                            var webSocket;\r\n                            var cookies = _this.httpClient.getCookieString(url);\r\n                            if (Platform.isNode && cookies) {\r\n                                // Only pass cookies when in non-browser environments\r\n                                webSocket = new _this.webSocketConstructor(url, undefined, {\r\n                                    headers: {\r\n                                        Cookie: \"\" + cookies,\r\n                                    },\r\n                                });\r\n                            }\r\n                            if (!webSocket) {\r\n                                // Chrome is not happy with passing 'undefined' as protocol\r\n                                webSocket = new _this.webSocketConstructor(url);\r\n                            }\r\n                            if (transferFormat === TransferFormat.Binary) {\r\n                                webSocket.binaryType = \"arraybuffer\";\r\n                            }\r\n                            // tslint:disable-next-line:variable-name\r\n                            webSocket.onopen = function (_event) {\r\n                                _this.logger.log(LogLevel.Information, \"WebSocket connected to \" + url + \".\");\r\n                                _this.webSocket = webSocket;\r\n                                resolve();\r\n                            };\r\n                            webSocket.onerror = function (event) {\r\n                                var error = null;\r\n                                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                                    error = event.error;\r\n                                }\r\n                                reject(error);\r\n                            };\r\n                            webSocket.onmessage = function (message) {\r\n                                _this.logger.log(LogLevel.Trace, \"(WebSockets transport) data received. \" + getDataDetail(message.data, _this.logMessageContent) + \".\");\r\n                                if (_this.onreceive) {\r\n                                    _this.onreceive(message.data);\r\n                                }\r\n                            };\r\n                            webSocket.onclose = function (event) { return _this.close(event); };\r\n                        })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    WebSocketTransport.prototype.send = function (data) {\r\n        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {\r\n            this.logger.log(LogLevel.Trace, \"(WebSockets transport) sending data. \" + getDataDetail(data, this.logMessageContent) + \".\");\r\n            this.webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    };\r\n    WebSocketTransport.prototype.stop = function () {\r\n        if (this.webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this.webSocket.onclose = function () { };\r\n            this.webSocket.onmessage = function () { };\r\n            this.webSocket.onerror = function () { };\r\n            this.webSocket.close();\r\n            this.webSocket = undefined;\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this.close(undefined);\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    WebSocketTransport.prototype.close = function (event) {\r\n        // webSocket will be null if the transport did not start successfully\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (event && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(\"WebSocket closed with status code: \" + event.code + \" (\" + event.reason + \").\"));\r\n            }\r\n            else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    };\r\n    return WebSocketTransport;\r\n}());\r\nexport { WebSocketTransport };\r\n//# sourceMappingURL=WebSocketTransport.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nvar XhrHttpClient = /** @class */ (function (_super) {\r\n    __extends(XhrHttpClient, _super);\r\n    function XhrHttpClient(logger) {\r\n        var _this = _super.call(this) || this;\r\n        _this.logger = logger;\r\n        return _this;\r\n    }\r\n    /** @inheritDoc */\r\n    XhrHttpClient.prototype.send = function (request) {\r\n        var _this = this;\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n        return new Promise(function (resolve, reject) {\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open(request.method, request.url, true);\r\n            xhr.withCredentials = true;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n            var headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach(function (header) {\r\n                    xhr.setRequestHeader(header, headers[header]);\r\n                });\r\n            }\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = function () {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n            xhr.onload = function () {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                }\r\n                else {\r\n                    reject(new HttpError(xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n            xhr.onerror = function () {\r\n                _this.logger.log(LogLevel.Warning, \"Error from HTTP request. \" + xhr.status + \": \" + xhr.statusText + \".\");\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n            xhr.ontimeout = function () {\r\n                _this.logger.log(LogLevel.Warning, \"Timeout from HTTP request.\");\r\n                reject(new TimeoutError());\r\n            };\r\n            xhr.send(request.content || \"\");\r\n        });\r\n    };\r\n    return XhrHttpClient;\r\n}(HttpClient));\r\nexport { XhrHttpClient };\r\n//# sourceMappingURL=XhrHttpClient.js.map","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\nexport var VERSION = \"0.0.0-DEV_BUILD\";\r\nexport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nexport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nexport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nexport { HubConnection, HubConnectionState } from \"./HubConnection\";\r\nexport { HubConnectionBuilder } from \"./HubConnectionBuilder\";\r\nexport { MessageType } from \"./IHubProtocol\";\r\nexport { LogLevel } from \"./ILogger\";\r\nexport { HttpTransportType, TransferFormat } from \"./ITransport\";\r\nexport { NullLogger } from \"./Loggers\";\r\nexport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nexport { Subject } from \"./Subject\";\r\n//# sourceMappingURL=index.js.map","\"use strict\";\n// This is a single-file self-contained module to avoid the need for a Webpack build\nvar DotNet;\n(function (DotNet) {\n    window.DotNet = DotNet; // Ensure reachable from anywhere\n    var jsonRevivers = [];\n    var pendingAsyncCalls = {};\n    var cachedJSFunctions = {};\n    var nextAsyncCallId = 1; // Start at 1 because zero signals \"no response needed\"\n    var dotNetDispatcher = null;\n    /**\n     * Sets the specified .NET call dispatcher as the current instance so that it will be used\n     * for future invocations.\n     *\n     * @param dispatcher An object that can dispatch calls from JavaScript to a .NET runtime.\n     */\n    function attachDispatcher(dispatcher) {\n        dotNetDispatcher = dispatcher;\n    }\n    DotNet.attachDispatcher = attachDispatcher;\n    /**\n     * Adds a JSON reviver callback that will be used when parsing arguments received from .NET.\n     * @param reviver The reviver to add.\n     */\n    function attachReviver(reviver) {\n        jsonRevivers.push(reviver);\n    }\n    DotNet.attachReviver = attachReviver;\n    /**\n     * Invokes the specified .NET public method synchronously. Not all hosting scenarios support\n     * synchronous invocation, so if possible use invokeMethodAsync instead.\n     *\n     * @param assemblyName The short name (without key/version or .dll extension) of the .NET assembly containing the method.\n     * @param methodIdentifier The identifier of the method to invoke. The method must have a [JSInvokable] attribute specifying this identifier.\n     * @param args Arguments to pass to the method, each of which must be JSON-serializable.\n     * @returns The result of the operation.\n     */\n    function invokeMethod(assemblyName, methodIdentifier) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        return invokePossibleInstanceMethod(assemblyName, methodIdentifier, null, args);\n    }\n    DotNet.invokeMethod = invokeMethod;\n    /**\n     * Invokes the specified .NET public method asynchronously.\n     *\n     * @param assemblyName The short name (without key/version or .dll extension) of the .NET assembly containing the method.\n     * @param methodIdentifier The identifier of the method to invoke. The method must have a [JSInvokable] attribute specifying this identifier.\n     * @param args Arguments to pass to the method, each of which must be JSON-serializable.\n     * @returns A promise representing the result of the operation.\n     */\n    function invokeMethodAsync(assemblyName, methodIdentifier) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        return invokePossibleInstanceMethodAsync(assemblyName, methodIdentifier, null, args);\n    }\n    DotNet.invokeMethodAsync = invokeMethodAsync;\n    function invokePossibleInstanceMethod(assemblyName, methodIdentifier, dotNetObjectId, args) {\n        var dispatcher = getRequiredDispatcher();\n        if (dispatcher.invokeDotNetFromJS) {\n            var argsJson = JSON.stringify(args, argReplacer);\n            var resultJson = dispatcher.invokeDotNetFromJS(assemblyName, methodIdentifier, dotNetObjectId, argsJson);\n            return resultJson ? parseJsonWithRevivers(resultJson) : null;\n        }\n        else {\n            throw new Error('The current dispatcher does not support synchronous calls from JS to .NET. Use invokeMethodAsync instead.');\n        }\n    }\n    function invokePossibleInstanceMethodAsync(assemblyName, methodIdentifier, dotNetObjectId, args) {\n        var asyncCallId = nextAsyncCallId++;\n        var resultPromise = new Promise(function (resolve, reject) {\n            pendingAsyncCalls[asyncCallId] = { resolve: resolve, reject: reject };\n        });\n        try {\n            var argsJson = JSON.stringify(args, argReplacer);\n            getRequiredDispatcher().beginInvokeDotNetFromJS(asyncCallId, assemblyName, methodIdentifier, dotNetObjectId, argsJson);\n        }\n        catch (ex) {\n            // Synchronous failure\n            completePendingCall(asyncCallId, false, ex);\n        }\n        return resultPromise;\n    }\n    function getRequiredDispatcher() {\n        if (dotNetDispatcher !== null) {\n            return dotNetDispatcher;\n        }\n        throw new Error('No .NET call dispatcher has been set.');\n    }\n    function completePendingCall(asyncCallId, success, resultOrError) {\n        if (!pendingAsyncCalls.hasOwnProperty(asyncCallId)) {\n            throw new Error(\"There is no pending async call with ID \" + asyncCallId + \".\");\n        }\n        var asyncCall = pendingAsyncCalls[asyncCallId];\n        delete pendingAsyncCalls[asyncCallId];\n        if (success) {\n            asyncCall.resolve(resultOrError);\n        }\n        else {\n            asyncCall.reject(resultOrError);\n        }\n    }\n    /**\n     * Receives incoming calls from .NET and dispatches them to JavaScript.\n     */\n    DotNet.jsCallDispatcher = {\n        /**\n         * Finds the JavaScript function matching the specified identifier.\n         *\n         * @param identifier Identifies the globally-reachable function to be returned.\n         * @returns A Function instance.\n         */\n        findJSFunction: findJSFunction,\n        /**\n         * Invokes the specified synchronous JavaScript function.\n         *\n         * @param identifier Identifies the globally-reachable function to invoke.\n         * @param argsJson JSON representation of arguments to be passed to the function.\n         * @returns JSON representation of the invocation result.\n         */\n        invokeJSFromDotNet: function (identifier, argsJson) {\n            var result = findJSFunction(identifier).apply(null, parseJsonWithRevivers(argsJson));\n            return result === null || result === undefined\n                ? null\n                : JSON.stringify(result, argReplacer);\n        },\n        /**\n         * Invokes the specified synchronous or asynchronous JavaScript function.\n         *\n         * @param asyncHandle A value identifying the asynchronous operation. This value will be passed back in a later call to endInvokeJSFromDotNet.\n         * @param identifier Identifies the globally-reachable function to invoke.\n         * @param argsJson JSON representation of arguments to be passed to the function.\n         */\n        beginInvokeJSFromDotNet: function (asyncHandle, identifier, argsJson) {\n            // Coerce synchronous functions into async ones, plus treat\n            // synchronous exceptions the same as async ones\n            var promise = new Promise(function (resolve) {\n                var synchronousResultOrPromise = findJSFunction(identifier).apply(null, parseJsonWithRevivers(argsJson));\n                resolve(synchronousResultOrPromise);\n            });\n            // We only listen for a result if the caller wants to be notified about it\n            if (asyncHandle) {\n                // On completion, dispatch result back to .NET\n                // Not using \"await\" because it codegens a lot of boilerplate\n                promise.then(function (result) { return getRequiredDispatcher().beginInvokeDotNetFromJS(0, 'Microsoft.JSInterop', 'DotNetDispatcher.EndInvoke', null, JSON.stringify([asyncHandle, true, result], argReplacer)); }, function (error) { return getRequiredDispatcher().beginInvokeDotNetFromJS(0, 'Microsoft.JSInterop', 'DotNetDispatcher.EndInvoke', null, JSON.stringify([asyncHandle, false, formatError(error)])); });\n            }\n        },\n        /**\n         * Receives notification that an async call from JS to .NET has completed.\n         * @param asyncCallId The identifier supplied in an earlier call to beginInvokeDotNetFromJS.\n         * @param success A flag to indicate whether the operation completed successfully.\n         * @param resultOrExceptionMessage Either the operation result or an error message.\n         */\n        endInvokeDotNetFromJS: function (asyncCallId, success, resultOrExceptionMessage) {\n            var resultOrError = success ? resultOrExceptionMessage : new Error(resultOrExceptionMessage);\n            completePendingCall(parseInt(asyncCallId), success, resultOrError);\n        }\n    };\n    function parseJsonWithRevivers(json) {\n        return json ? JSON.parse(json, function (key, initialValue) {\n            // Invoke each reviver in order, passing the output from the previous reviver,\n            // so that each one gets a chance to transform the value\n            return jsonRevivers.reduce(function (latestValue, reviver) { return reviver(key, latestValue); }, initialValue);\n        }) : null;\n    }\n    function formatError(error) {\n        if (error instanceof Error) {\n            return error.message + \"\\n\" + error.stack;\n        }\n        else {\n            return error ? error.toString() : 'null';\n        }\n    }\n    function findJSFunction(identifier) {\n        if (cachedJSFunctions.hasOwnProperty(identifier)) {\n            return cachedJSFunctions[identifier];\n        }\n        var result = window;\n        var resultIdentifier = 'window';\n        identifier.split('.').forEach(function (segment) {\n            if (segment in result) {\n                result = result[segment];\n                resultIdentifier += '.' + segment;\n            }\n            else {\n                throw new Error(\"Could not find '\" + segment + \"' in '\" + resultIdentifier + \"'.\");\n            }\n        });\n        if (result instanceof Function) {\n            return result;\n        }\n        else {\n            throw new Error(\"The value '\" + resultIdentifier + \"' is not a function.\");\n        }\n    }\n    var DotNetObject = /** @class */ (function () {\n        function DotNetObject(_id) {\n            this._id = _id;\n        }\n        DotNetObject.prototype.invokeMethod = function (methodIdentifier) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            return invokePossibleInstanceMethod(null, methodIdentifier, this._id, args);\n        };\n        DotNetObject.prototype.invokeMethodAsync = function (methodIdentifier) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            return invokePossibleInstanceMethodAsync(null, methodIdentifier, this._id, args);\n        };\n        DotNetObject.prototype.dispose = function () {\n            var promise = invokeMethodAsync('Microsoft.JSInterop', 'DotNetDispatcher.ReleaseDotNetObject', this._id);\n            promise.catch(function (error) { return console.error(error); });\n        };\n        DotNetObject.prototype.serializeAsArg = function () {\n            return { __dotNetObject: this._id };\n        };\n        return DotNetObject;\n    }());\n    var dotNetObjectRefKey = '__dotNetObject';\n    attachReviver(function reviveDotNetObject(key, value) {\n        if (value && typeof value === 'object' && value.hasOwnProperty(dotNetObjectRefKey)) {\n            return new DotNetObject(value.__dotNetObject);\n        }\n        // Unrecognized - let another reviver handle it\n        return value;\n    });\n    function argReplacer(key, value) {\n        return value instanceof DotNetObject ? value.serializeAsArg() : value;\n    }\n})(DotNet || (DotNet = {}));\n//# sourceMappingURL=Microsoft.JSInterop.js.map","'use strict';\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import '@dotnet/jsinterop';\r\nimport './GlobalExports';\r\nimport * as signalR from '@aspnet/signalr';\r\nimport { MessagePackHubProtocol } from '@aspnet/signalr-protocol-msgpack';\r\nimport { fetchBootConfigAsync, loadEmbeddedResourcesAsync, shouldAutoStart } from './BootCommon';\r\nimport { CircuitHandler } from './Platform/Circuits/CircuitHandler';\r\nimport { AutoReconnectCircuitHandler } from './Platform/Circuits/AutoReconnectCircuitHandler';\r\nimport RenderQueue from './Platform/Circuits/RenderQueue';\r\nimport { ConsoleLogger } from './Platform/Logging/Loggers';\r\nimport { LogLevel, ILogger } from './Platform/Logging/ILogger';\r\nimport { discoverPrerenderedCircuits, startCircuit } from './Platform/Circuits/CircuitManager';\r\n\r\n\r\ntype SignalRBuilder = (builder: signalR.HubConnectionBuilder) => void;\r\ninterface BlazorOptions {\r\n  configureSignalR: SignalRBuilder;\r\n  logLevel: LogLevel;\r\n}\r\n\r\nlet renderingFailed = false;\r\nlet started = false;\r\n\r\nasync function boot(userOptions?: Partial<BlazorOptions>): Promise<void> {\r\n\r\n  if (started) {\r\n    throw new Error('Blazor has already started.');\r\n  }\r\n  started = true;\r\n\r\n  const defaultOptions: BlazorOptions = {\r\n    configureSignalR: (_) => { },\r\n    logLevel: LogLevel.Warning,\r\n  };\r\n\r\n  const options: BlazorOptions = { ...defaultOptions, ...userOptions };\r\n\r\n  // For development.\r\n  // Simply put a break point here and modify the log level during\r\n  // development to get traces.\r\n  // In the future we will allow for users to configure this.\r\n  const logger = new ConsoleLogger(options.logLevel);\r\n\r\n  logger.log(LogLevel.Information, 'Starting up blazor server-side application.');\r\n\r\n  const circuitHandlers: CircuitHandler[] = [new AutoReconnectCircuitHandler(logger)];\r\n  window['Blazor'].circuitHandlers = circuitHandlers;\r\n\r\n  // In the background, start loading the boot config and any embedded resources\r\n  const embeddedResourcesPromise = fetchBootConfigAsync().then(bootConfig => {\r\n    return loadEmbeddedResourcesAsync(bootConfig);\r\n  });\r\n\r\n  // pass options.configureSignalR to configure the signalR.HubConnectionBuilder\r\n  const initialConnection = await initializeConnection(options, circuitHandlers, logger);\r\n\r\n  const circuits = discoverPrerenderedCircuits(document);\r\n  for (let i = 0; i < circuits.length; i++) {\r\n    const circuit = circuits[i];\r\n    for (let j = 0; j < circuit.components.length; j++) {\r\n      const component = circuit.components[j];\r\n      component.initialize();\r\n    }\r\n  }\r\n\r\n  // Ensure any embedded resources have been loaded before starting the app\r\n  await embeddedResourcesPromise;\r\n\r\n  const circuit = await startCircuit(initialConnection);\r\n\r\n  if (!circuit) {\r\n    logger.log(LogLevel.Information, 'No preregistered components to render.');\r\n  }\r\n\r\n  const reconnect = async (existingConnection?: signalR.HubConnection): Promise<boolean> => {\r\n    if (renderingFailed) {\r\n      // We can't reconnect after a failure, so exit early.\r\n      return false;\r\n    }\r\n    const reconnection = existingConnection || await initializeConnection(options, circuitHandlers, logger);\r\n    const results = await Promise.all(circuits.map(circuit => circuit.reconnect(reconnection)));\r\n\r\n    if (reconnectionFailed(results)) {\r\n      return false;\r\n    }\r\n\r\n    circuitHandlers.forEach(h => h.onConnectionUp && h.onConnectionUp());\r\n    return true;\r\n  };\r\n\r\n  window['Blazor'].reconnect = reconnect;\r\n\r\n  const reconnectTask = reconnect(initialConnection);\r\n\r\n  if (circuit) {\r\n    circuits.push(circuit);\r\n  }\r\n\r\n  await reconnectTask;\r\n\r\n  logger.log(LogLevel.Information, 'Blazor server-side application started.');\r\n\r\n  function reconnectionFailed(results: boolean[]): boolean {\r\n    return !results.reduce((current, next) => current && next, true);\r\n  }\r\n}\r\n\r\nasync function initializeConnection(options: Required<BlazorOptions>, circuitHandlers: CircuitHandler[], logger: ILogger): Promise<signalR.HubConnection> {\r\n\r\n  const hubProtocol = new MessagePackHubProtocol();\r\n  (hubProtocol as unknown as { name: string }).name = 'blazorpack';\r\n\r\n  const connectionBuilder = new signalR.HubConnectionBuilder()\r\n    .withUrl('_blazor')\r\n    .withHubProtocol(hubProtocol);\r\n\r\n  options.configureSignalR(connectionBuilder);\r\n\r\n  const connection = connectionBuilder.build();\r\n\r\n  connection.on('JS.BeginInvokeJS', DotNet.jsCallDispatcher.beginInvokeJSFromDotNet);\r\n  connection.on('JS.RenderBatch', (browserRendererId: number, batchId: number, batchData: Uint8Array) => {\r\n    logger.log(LogLevel.Debug, `Received render batch for ${browserRendererId} with id ${batchId} and ${batchData.byteLength} bytes.`);\r\n\r\n    const queue = RenderQueue.getOrCreateQueue(browserRendererId, logger);\r\n\r\n    queue.processBatch(batchId, batchData, connection);\r\n  });\r\n\r\n  connection.onclose(error => !renderingFailed && circuitHandlers.forEach(h => h.onConnectionDown && h.onConnectionDown(error)));\r\n  connection.on('JS.Error', error => unhandledError(connection, error, logger));\r\n\r\n  window['Blazor']._internal.forceCloseConnection = () => connection.stop();\r\n\r\n  try {\r\n    await connection.start();\r\n  } catch (ex) {\r\n    unhandledError(connection, ex, logger);\r\n  }\r\n\r\n  DotNet.attachDispatcher({\r\n    beginInvokeDotNetFromJS: (callId, assemblyName, methodIdentifier, dotNetObjectId, argsJson) => {\r\n      connection.send('BeginInvokeDotNetFromJS', callId ? callId.toString() : null, assemblyName, methodIdentifier, dotNetObjectId || 0, argsJson);\r\n    },\r\n  });\r\n\r\n  return connection;\r\n}\r\n\r\nfunction unhandledError(connection: signalR.HubConnection, err: Error, logger: ILogger): void {\r\n  logger.log(LogLevel.Error, err);\r\n\r\n  // Disconnect on errors.\r\n  //\r\n  // Trying to call methods on the connection after its been closed will throw.\r\n  if (connection) {\r\n    renderingFailed = true;\r\n    connection.stop();\r\n  }\r\n}\r\n\r\nwindow['Blazor'].start = boot;\r\nif (shouldAutoStart()) {\r\n  boot();\r\n}\r\n","export async function fetchBootConfigAsync() {\r\n  // Later we might make the location of this configurable (e.g., as an attribute on the <script>\r\n  // element that's importing this file), but currently there isn't a use case for that.\r\n  const bootConfigResponse = await fetch('_framework/blazor.boot.json', { method: 'Get', credentials: 'include' });\r\n  return bootConfigResponse.json() as Promise<BootJsonData>;\r\n}\r\n\r\nexport function loadEmbeddedResourcesAsync(bootConfig: BootJsonData): Promise<any> {\r\n  const cssLoadingPromises = bootConfig.cssReferences.map(cssReference => {\r\n    const linkElement = document.createElement('link');\r\n    linkElement.rel = 'stylesheet';\r\n    linkElement.href = cssReference;\r\n    return loadResourceFromElement(linkElement);\r\n  });\r\n  const jsLoadingPromises = bootConfig.jsReferences.map(jsReference => {\r\n    const scriptElement = document.createElement('script');\r\n    scriptElement.src = jsReference;\r\n    return loadResourceFromElement(scriptElement);\r\n  });\r\n  return Promise.all(cssLoadingPromises.concat(jsLoadingPromises));\r\n}\r\n\r\nfunction loadResourceFromElement(element: HTMLElement) {\r\n  return new Promise((resolve, reject) => {\r\n    element.onload = resolve;\r\n    element.onerror = reject;\r\n    document.head!.appendChild(element);\r\n  });\r\n}\r\n\r\n// Keep in sync with BootJsonData in Microsoft.AspNetCore.Blazor.Build\r\ninterface BootJsonData {\r\n  main: string;\r\n  entryPoint: string;\r\n  assemblyReferences: string[];\r\n  cssReferences: string[];\r\n  jsReferences: string[];\r\n  linkerEnabled: boolean;\r\n}\r\n\r\n// Tells you if the script was added without <script src=\"...\" autostart=\"false\"></script>\r\nexport function shouldAutoStart() {\r\n  return document &&\r\n    document.currentScript &&\r\n    document.currentScript.getAttribute('autostart') !== 'false';\r\n}","// Expose an export called 'platform' of the interface type 'Platform',\r\n// so that consumers can be agnostic about which implementation they use.\r\n// Basic alternative to having an actual DI container.\r\nimport { Platform } from './Platform/Platform';\r\n\r\nexport let platform: Platform;\r\n\r\nexport function setPlatform(platformInstance: Platform) {\r\n  platform = platformInstance;\r\n  return platform;\r\n}\r\n","import { navigateTo, internalFunctions as uriHelperInternalFunctions } from './Services/UriHelper';\r\nimport { internalFunctions as httpInternalFunctions } from './Services/Http';\r\nimport { attachRootComponentToElement } from './Rendering/Renderer';\r\n\r\n// Make the following APIs available in global scope for invocation from JS\r\nwindow['Blazor'] = {\r\n  navigateTo,\r\n\r\n  _internal: {\r\n    attachRootComponentToElement,\r\n    http: httpInternalFunctions,\r\n    uriHelper: uriHelperInternalFunctions,\r\n  },\r\n};\r\n","import { CircuitHandler } from './CircuitHandler';\r\nimport { UserSpecifiedDisplay } from './UserSpecifiedDisplay';\r\nimport { DefaultReconnectDisplay } from './DefaultReconnectDisplay';\r\nimport { ReconnectDisplay } from './ReconnectDisplay';\r\nimport { ILogger, LogLevel } from '../Logging/ILogger';\r\nexport class AutoReconnectCircuitHandler implements CircuitHandler {\r\n  public static readonly MaxRetries = 5;\r\n\r\n  public static readonly RetryInterval = 3000;\r\n\r\n  public static readonly DialogId = 'components-reconnect-modal';\r\n\r\n  public reconnectDisplay: ReconnectDisplay;\r\n\r\n  public logger: ILogger;\r\n\r\n  public constructor(logger: ILogger) {\r\n    this.logger = logger;\r\n    this.reconnectDisplay = new DefaultReconnectDisplay(document);\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n      const modal = document.getElementById(AutoReconnectCircuitHandler.DialogId);\r\n      if (modal) {\r\n        this.reconnectDisplay = new UserSpecifiedDisplay(modal);\r\n      }\r\n    });\r\n  }\r\n\r\n  public onConnectionUp(): void {\r\n    this.reconnectDisplay.hide();\r\n  }\r\n\r\n  public delay(): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, AutoReconnectCircuitHandler.RetryInterval));\r\n  }\r\n\r\n  public async onConnectionDown(): Promise<void> {\r\n    this.reconnectDisplay.show();\r\n\r\n    for (let i = 0; i < AutoReconnectCircuitHandler.MaxRetries; i++) {\r\n      await this.delay();\r\n      try {\r\n        const result = await window['Blazor'].reconnect();\r\n        if (!result) {\r\n          // If the server responded and refused to reconnect, stop auto-retrying.\r\n          break;\r\n        }\r\n        return;\r\n      } catch (err) {\r\n        this.logger.log(LogLevel.Error, err);\r\n      }\r\n    }\r\n\r\n    this.reconnectDisplay.failed();\r\n  }\r\n}\r\n","import { internalFunctions as uriHelperFunctions } from '../../Services/UriHelper';\r\nimport { ComponentDescriptor, MarkupRegistrationTags, StartComponentComment, EndComponentComment } from './ComponentDescriptor';\r\n\r\nexport class CircuitDescriptor {\r\n  public circuitId: string;\r\n\r\n  public components: ComponentDescriptor[];\r\n\r\n  public constructor(circuitId: string, components: ComponentDescriptor[]) {\r\n    this.circuitId = circuitId;\r\n    this.components = components;\r\n  }\r\n\r\n  public reconnect(reconnection: signalR.HubConnection): Promise<boolean> {\r\n    return reconnection.invoke<boolean>('ConnectCircuit', this.circuitId);\r\n  }\r\n}\r\n\r\n\r\nexport function discoverPrerenderedCircuits(document: Document): CircuitDescriptor[] {\r\n  const commentPairs = resolveCommentPairs(document);\r\n  const discoveredCircuits = new Map<string, ComponentDescriptor[]>();\r\n  for (let i = 0; i < commentPairs.length; i++) {\r\n    const pair = commentPairs[i];\r\n    let circuit = discoveredCircuits.get(pair.start.circuitId);\r\n    if (!circuit) {\r\n      circuit = [];\r\n      discoveredCircuits.set(pair.start.circuitId, circuit);\r\n    }\r\n    const entry = new ComponentDescriptor(pair.start.componentId, pair.start.circuitId, pair.start.rendererId, pair);\r\n    circuit.push(entry);\r\n  }\r\n  const circuits: CircuitDescriptor[] = [];\r\n  for (const [key, values] of discoveredCircuits) {\r\n    circuits.push(new CircuitDescriptor(key, values));\r\n  }\r\n  return circuits;\r\n}\r\n\r\nexport async function startCircuit(connection: signalR.HubConnection): Promise<CircuitDescriptor | undefined> {\r\n  const result = await connection.invoke<string>('StartCircuit', uriHelperFunctions.getLocationHref(), uriHelperFunctions.getBaseURI());\r\n  if (result) {\r\n    return new CircuitDescriptor(result, []);\r\n  } else {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nfunction resolveCommentPairs(node: Node): MarkupRegistrationTags[] {\r\n  if (!node.hasChildNodes()) {\r\n    return [];\r\n  }\r\n  const result: MarkupRegistrationTags[] = [];\r\n  const children = node.childNodes;\r\n  let i = 0;\r\n  const childrenLength = children.length;\r\n  while (i < childrenLength) {\r\n    const currentChildNode = children[i];\r\n    const startComponent = getComponentStartComment(currentChildNode);\r\n    if (!startComponent) {\r\n      i++;\r\n      const childResults = resolveCommentPairs(currentChildNode);\r\n      for (let j = 0; j < childResults.length; j++) {\r\n        const childResult = childResults[j];\r\n        result.push(childResult);\r\n      }\r\n      continue;\r\n    }\r\n    const endComponent = getComponentEndComment(startComponent, children, i + 1, childrenLength);\r\n    result.push({ start: startComponent, end: endComponent });\r\n    i = endComponent.index + 1;\r\n  }\r\n  return result;\r\n}\r\nfunction getComponentStartComment(node: Node): StartComponentComment | undefined {\r\n  if (node.nodeType !== Node.COMMENT_NODE) {\r\n    return;\r\n  }\r\n  if (node.textContent) {\r\n    const componentStartComment = /\\W+M.A.C.Component:[^{]*(.*)$/;\r\n    const definition = componentStartComment.exec(node.textContent);\r\n    const json = definition && definition[1];\r\n    if (json) {\r\n      try {\r\n        const { componentId, circuitId, rendererId } = JSON.parse(json);\r\n        const allComponents = !!componentId && !!circuitId && !!rendererId;\r\n        if (allComponents) {\r\n          return {\r\n            node: node as Comment,\r\n            circuitId,\r\n            rendererId: Number.parseInt(rendererId),\r\n            componentId: Number.parseInt(componentId),\r\n          };\r\n        } else {\r\n          throw new Error(`Found malformed start component comment at ${node.textContent}`);\r\n        }\r\n      } catch (error) {\r\n        throw new Error(`Found malformed start component comment at ${node.textContent}`);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction getComponentEndComment(component: StartComponentComment, children: NodeList, index: number, end: number): EndComponentComment {\r\n  for (let i = index; i < end; i++) {\r\n    const node = children[i];\r\n    if (node.nodeType !== Node.COMMENT_NODE) {\r\n      continue;\r\n    }\r\n    if (!node.textContent) {\r\n      continue;\r\n    }\r\n    const componentEndComment = /\\W+M.A.C.Component:\\W+(\\d+)\\W+$/;\r\n    const definition = componentEndComment.exec(node.textContent);\r\n    const rawComponentId = definition && definition[1];\r\n    if (!rawComponentId) {\r\n      continue;\r\n    }\r\n    try {\r\n      const componentId = Number.parseInt(rawComponentId);\r\n      if (componentId === component.componentId) {\r\n        return { componentId, node: node as Comment, index: i };\r\n      } else {\r\n        throw new Error(`Found malformed end component comment at ${node.textContent}`);\r\n      }\r\n    } catch (error) {\r\n      throw new Error(`Found malformed end component comment at ${node.textContent}`);\r\n    }\r\n  }\r\n  throw new Error(`End component comment not found for ${component.node}`);\r\n}\r\n","import { attachRootComponentToLogicalElement } from '../../Rendering/Renderer';\r\nimport { toLogicalRootCommentElement } from '../../Rendering/LogicalElements';\r\n\r\nexport interface EndComponentComment {\r\n  componentId: number;\r\n  node: Comment;\r\n  index: number;\r\n}\r\n\r\nexport interface StartComponentComment {\r\n  node: Comment;\r\n  rendererId: number;\r\n  componentId: number;\r\n  circuitId: string;\r\n}\r\n\r\n// Represent pairs of start end comments indicating a component that was registered\r\n// in markup (such as a prerendered component)\r\nexport interface MarkupRegistrationTags {\r\n  start: StartComponentComment;\r\n  end: EndComponentComment;\r\n}\r\n\r\nexport class ComponentDescriptor {\r\n  public registrationTags: MarkupRegistrationTags;\r\n\r\n  public componentId: number;\r\n\r\n  public circuitId: string;\r\n\r\n  public rendererId: number;\r\n\r\n  public constructor(componentId: number, circuitId: string, rendererId: number, descriptor: MarkupRegistrationTags) {\r\n    this.componentId = componentId;\r\n    this.circuitId = circuitId;\r\n    this.rendererId = rendererId;\r\n    this.registrationTags = descriptor;\r\n  }\r\n\r\n  public initialize(): void {\r\n    const startEndPair = { start: this.registrationTags.start.node, end: this.registrationTags.end.node };\r\n\r\n    const logicalElement = toLogicalRootCommentElement(startEndPair.start, startEndPair.end);\r\n    attachRootComponentToLogicalElement(this.rendererId, logicalElement, this.componentId);\r\n  }\r\n}\r\n","import { ReconnectDisplay } from './ReconnectDisplay';\r\nimport { AutoReconnectCircuitHandler } from './AutoReconnectCircuitHandler';\r\nexport class DefaultReconnectDisplay implements ReconnectDisplay {\r\n  modal: HTMLDivElement;\r\n\r\n  message: HTMLHeadingElement;\r\n\r\n  button: HTMLButtonElement;\r\n\r\n  addedToDom: boolean = false;\r\n\r\n  constructor(private document: Document) {\r\n    this.modal = this.document.createElement('div');\r\n    this.modal.id = AutoReconnectCircuitHandler.DialogId;\r\n\r\n    const modalStyles = [\r\n      'position: fixed',\r\n      'top: 0',\r\n      'right: 0',\r\n      'bottom: 0',\r\n      'left: 0',\r\n      'z-index: 1000',\r\n      'display: none',\r\n      'overflow: hidden',\r\n      'background-color: #fff',\r\n      'opacity: 0.8',\r\n      'text-align: center',\r\n      'font-weight: bold',\r\n    ];\r\n\r\n    this.modal.style.cssText = modalStyles.join(';');\r\n    this.modal.innerHTML = '<h5 style=\"margin-top: 20px\"></h5><button style=\"margin:5px auto 5px\">Retry?</button>';\r\n    this.message = this.modal.querySelector('h5')!;\r\n    this.button = this.modal.querySelector('button')!;\r\n\r\n    this.button.addEventListener('click', () => window['Blazor'].reconnect());\r\n  }\r\n\r\n  show(): void {\r\n    if (!this.addedToDom) {\r\n      this.addedToDom = true;\r\n      this.document.body.appendChild(this.modal);\r\n    }\r\n    this.modal.style.display = 'block';\r\n    this.button.style.display = 'none';\r\n    this.message.textContent = 'Attempting to reconnect to the server...';\r\n  }\r\n\r\n  hide(): void {\r\n    this.modal.style.display = 'none';\r\n  }\r\n\r\n  failed(): void {\r\n    this.button.style.display = 'block';\r\n    this.message.textContent = 'Failed to reconnect to the server.';\r\n  }\r\n}\r\n","import { renderBatch } from '../../Rendering/Renderer';\r\nimport { OutOfProcessRenderBatch } from '../../Rendering/RenderBatch/OutOfProcessRenderBatch';\r\nimport { ILogger, LogLevel } from '../Logging/ILogger';\r\nimport { HubConnection } from '@aspnet/signalr';\r\n\r\nexport default class RenderQueue {\r\n  private static renderQueues = new Map<number, RenderQueue>();\r\n\r\n  private nextBatchId = 2;\r\n\r\n  public browserRendererId: number;\r\n\r\n  public logger: ILogger;\r\n\r\n  public constructor(browserRendererId: number, logger: ILogger) {\r\n    this.browserRendererId = browserRendererId;\r\n    this.logger = logger;\r\n  }\r\n\r\n  public static getOrCreateQueue(browserRendererId: number, logger: ILogger): RenderQueue {\r\n    const queue = this.renderQueues.get(browserRendererId);\r\n    if (queue) {\r\n      return queue;\r\n    }\r\n\r\n    const newQueue = new RenderQueue(browserRendererId, logger);\r\n    this.renderQueues.set(browserRendererId, newQueue);\r\n    return newQueue;\r\n  }\r\n\r\n  public processBatch(receivedBatchId: number, batchData: Uint8Array, connection: HubConnection): void {\r\n    if (receivedBatchId < this.nextBatchId) {\r\n      this.logger.log(LogLevel.Debug, `Batch ${receivedBatchId} already processed. Waiting for batch ${this.nextBatchId}.`);\r\n      return;\r\n    }\r\n\r\n    if (receivedBatchId > this.nextBatchId) {\r\n      this.logger.log(LogLevel.Debug, `Waiting for batch ${this.nextBatchId}. Batch ${receivedBatchId} not processed.`);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.nextBatchId++;\r\n      this.logger.log(LogLevel.Debug, `Applying batch ${receivedBatchId}.`);\r\n      renderBatch(this.browserRendererId, new OutOfProcessRenderBatch(batchData));\r\n      this.completeBatch(connection, receivedBatchId);\r\n    } catch (error) {\r\n      this.logger.log(LogLevel.Error, `There was an error applying batch ${receivedBatchId}.`);\r\n\r\n      // If there's a rendering exception, notify server *and* throw on client\r\n      connection.send('OnRenderCompleted', receivedBatchId, error.toString());\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public getLastBatchid(): number {\r\n    return this.nextBatchId - 1;\r\n  }\r\n\r\n  private async completeBatch(connection: signalR.HubConnection, batchId: number): Promise<void> {\r\n    try {\r\n      await connection.send('OnRenderCompleted', batchId, null);\r\n    } catch {\r\n      this.logger.log(LogLevel.Warning, `Failed to deliver completion notification for render '${batchId}'.`);\r\n    }\r\n  }\r\n}\r\n","import { ReconnectDisplay } from './ReconnectDisplay';\r\nexport class UserSpecifiedDisplay implements ReconnectDisplay {\r\n  static readonly ShowClassName = 'components-reconnect-show';\r\n\r\n  static readonly HideClassName = 'components-reconnect-hide';\r\n\r\n  static readonly FailedClassName = 'components-reconnect-failed';\r\n\r\n  constructor(private dialog: HTMLElement) {\r\n  }\r\n\r\n  show(): void {\r\n    this.removeClasses();\r\n    this.dialog.classList.add(UserSpecifiedDisplay.ShowClassName);\r\n  }\r\n\r\n  hide(): void {\r\n    this.removeClasses();\r\n    this.dialog.classList.add(UserSpecifiedDisplay.HideClassName);\r\n  }\r\n\r\n  failed(): void {\r\n    this.removeClasses();\r\n    this.dialog.classList.add(UserSpecifiedDisplay.FailedClassName);\r\n  }\r\n\r\n  private removeClasses() {\r\n    this.dialog.classList.remove(UserSpecifiedDisplay.ShowClassName, UserSpecifiedDisplay.HideClassName, UserSpecifiedDisplay.FailedClassName);\r\n  }\r\n}\r\n","// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport enum LogLevel {\r\n  /** Log level for very low severity diagnostic messages. */\r\n  Trace = 0,\r\n  /** Log level for low severity diagnostic messages. */\r\n  Debug = 1,\r\n  /** Log level for informational diagnostic messages. */\r\n  Information = 2,\r\n  /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n  Warning = 3,\r\n  /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n  Error = 4,\r\n  /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n  Critical = 5,\r\n  /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n  None = 6,\r\n}\r\n\r\n/** An abstraction that provides a sink for diagnostic messages. */\r\nexport interface ILogger { // eslint-disable-line @typescript-eslint/interface-name-prefix\r\n  /** Called by the framework to emit a diagnostic message.\r\n   *\r\n   * @param {LogLevel} logLevel The severity level of the message.\r\n   * @param {string} message The message.\r\n   */\r\n  log(logLevel: LogLevel, message: string | Error): void;\r\n}\r\n","/* eslint-disable no-console */\r\n\r\nimport { ILogger, LogLevel } from './ILogger';\r\n\r\nexport class NullLogger implements ILogger {\r\n  public static instance: ILogger = new NullLogger();\r\n\r\n  private constructor() { }\r\n\r\n  public log(_logLevel: LogLevel, _message: string): void { // eslint-disable-line @typescript-eslint/no-unused-vars\r\n  }\r\n}\r\n\r\nexport class ConsoleLogger implements ILogger {\r\n  private readonly minimumLogLevel: LogLevel;\r\n\r\n  public constructor(minimumLogLevel: LogLevel) {\r\n    this.minimumLogLevel = minimumLogLevel;\r\n  }\r\n\r\n  public log(logLevel: LogLevel, message: string | Error): void {\r\n    if (logLevel >= this.minimumLogLevel) {\r\n      switch (logLevel) {\r\n        case LogLevel.Critical:\r\n        case LogLevel.Error:\r\n          console.error(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n          break;\r\n        case LogLevel.Warning:\r\n          console.warn(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n          break;\r\n        case LogLevel.Information:\r\n          console.info(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n          break;\r\n        default:\r\n          // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n          console.log(`[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { RenderBatch, ArraySegment, RenderTreeEdit, RenderTreeFrame, EditType, FrameType, ArrayValues } from './RenderBatch/RenderBatch';\r\nimport { EventDelegator } from './EventDelegator';\r\nimport { EventForDotNet, UIEventArgs } from './EventForDotNet';\r\nimport { LogicalElement, PermutationListEntry, toLogicalElement, insertLogicalChild, removeLogicalChild, getLogicalParent, getLogicalChild, createAndInsertLogicalContainer, isSvgElement, getLogicalChildrenArray, getLogicalSiblingEnd, permuteLogicalChildren, getClosestDomElement } from './LogicalElements';\r\nimport { applyCaptureIdToElement } from './ElementReferenceCapture';\r\nconst selectValuePropname = '_blazorSelectValue';\r\nconst sharedTemplateElemForParsing = document.createElement('template');\r\nconst sharedSvgElemForParsing = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\nconst preventDefaultEvents: { [eventType: string]: boolean } = { submit: true };\r\nconst rootComponentsPendingFirstRender: { [componentId: number]: LogicalElement } = {};\r\n\r\nexport class BrowserRenderer {\r\n  private eventDelegator: EventDelegator;\r\n\r\n  private childComponentLocations: { [componentId: number]: LogicalElement } = {};\r\n\r\n  private browserRendererId: number;\r\n\r\n  public constructor(browserRendererId: number) {\r\n    this.browserRendererId = browserRendererId;\r\n    this.eventDelegator = new EventDelegator((event, eventHandlerId, eventArgs) => {\r\n      raiseEvent(event, this.browserRendererId, eventHandlerId, eventArgs);\r\n    });\r\n  }\r\n\r\n  public attachRootComponentToLogicalElement(componentId: number, element: LogicalElement): void {\r\n    this.attachComponentToElement(componentId, element);\r\n    rootComponentsPendingFirstRender[componentId] = element;\r\n  }\r\n\r\n  public updateComponent(batch: RenderBatch, componentId: number, edits: ArraySegment<RenderTreeEdit>, referenceFrames: ArrayValues<RenderTreeFrame>): void {\r\n    const element = this.childComponentLocations[componentId];\r\n    if (!element) {\r\n      throw new Error(`No element is currently associated with component ${componentId}`);\r\n    }\r\n\r\n    // On the first render for each root component, clear any existing content (e.g., prerendered)\r\n    const rootElementToClear = rootComponentsPendingFirstRender[componentId];\r\n    if (rootElementToClear) {\r\n      const rootElementToClearEnd = getLogicalSiblingEnd(rootElementToClear);\r\n      delete rootComponentsPendingFirstRender[componentId];\r\n\r\n      if (!rootElementToClearEnd) {\r\n        clearElement(rootElementToClear as unknown as Element);\r\n      } else {\r\n        clearBetween(rootElementToClear as unknown as Node, rootElementToClearEnd as unknown as Comment);\r\n      }\r\n    }\r\n\r\n    const ownerDocument = getClosestDomElement(element).ownerDocument;\r\n    const activeElementBefore = ownerDocument && ownerDocument.activeElement;\r\n\r\n    this.applyEdits(batch, element, 0, edits, referenceFrames);\r\n\r\n    // Try to restore focus in case it was lost due to an element move\r\n    if ((activeElementBefore instanceof HTMLElement) && ownerDocument && ownerDocument.activeElement !== activeElementBefore) {\r\n      activeElementBefore.focus();\r\n    }\r\n  }\r\n\r\n  public disposeComponent(componentId: number) {\r\n    delete this.childComponentLocations[componentId];\r\n  }\r\n\r\n  public disposeEventHandler(eventHandlerId: number) {\r\n    this.eventDelegator.removeListener(eventHandlerId);\r\n  }\r\n\r\n  private attachComponentToElement(componentId: number, element: LogicalElement) {\r\n    this.childComponentLocations[componentId] = element;\r\n  }\r\n\r\n  private applyEdits(batch: RenderBatch, parent: LogicalElement, childIndex: number, edits: ArraySegment<RenderTreeEdit>, referenceFrames: ArrayValues<RenderTreeFrame>) {\r\n    let currentDepth = 0;\r\n    let childIndexAtCurrentDepth = childIndex;\r\n    let permutationList: PermutationListEntry[] | undefined;\r\n\r\n    const arraySegmentReader = batch.arraySegmentReader;\r\n    const editReader = batch.editReader;\r\n    const frameReader = batch.frameReader;\r\n    const editsValues = arraySegmentReader.values(edits);\r\n    const editsOffset = arraySegmentReader.offset(edits);\r\n    const editsLength = arraySegmentReader.count(edits);\r\n    const maxEditIndexExcl = editsOffset + editsLength;\r\n\r\n    for (let editIndex = editsOffset; editIndex < maxEditIndexExcl; editIndex++) {\r\n      const edit = batch.diffReader.editsEntry(editsValues, editIndex);\r\n      const editType = editReader.editType(edit);\r\n      switch (editType) {\r\n        case EditType.prependFrame: {\r\n          const frameIndex = editReader.newTreeIndex(edit);\r\n          const frame = batch.referenceFramesEntry(referenceFrames, frameIndex);\r\n          const siblingIndex = editReader.siblingIndex(edit);\r\n          this.insertFrame(batch, parent, childIndexAtCurrentDepth + siblingIndex, referenceFrames, frame, frameIndex);\r\n          break;\r\n        }\r\n        case EditType.removeFrame: {\r\n          const siblingIndex = editReader.siblingIndex(edit);\r\n          removeLogicalChild(parent, childIndexAtCurrentDepth + siblingIndex);\r\n          break;\r\n        }\r\n        case EditType.setAttribute: {\r\n          const frameIndex = editReader.newTreeIndex(edit);\r\n          const frame = batch.referenceFramesEntry(referenceFrames, frameIndex);\r\n          const siblingIndex = editReader.siblingIndex(edit);\r\n          const element = getLogicalChild(parent, childIndexAtCurrentDepth + siblingIndex);\r\n          if (element instanceof Element) {\r\n            this.applyAttribute(batch, element, frame);\r\n          } else {\r\n            throw new Error('Cannot set attribute on non-element child');\r\n          }\r\n          break;\r\n        }\r\n        case EditType.removeAttribute: {\r\n          // Note that we don't have to dispose the info we track about event handlers here, because the\r\n          // disposed event handler IDs are delivered separately (in the 'disposedEventHandlerIds' array)\r\n          const siblingIndex = editReader.siblingIndex(edit);\r\n          const element = getLogicalChild(parent, childIndexAtCurrentDepth + siblingIndex);\r\n          if (element instanceof HTMLElement) {\r\n            const attributeName = editReader.removedAttributeName(edit)!;\r\n            // First try to remove any special property we use for this attribute\r\n            if (!this.tryApplySpecialProperty(batch, element, attributeName, null)) {\r\n              // If that's not applicable, it's a regular DOM attribute so remove that\r\n              element.removeAttribute(attributeName);\r\n            }\r\n          } else {\r\n            throw new Error('Cannot remove attribute from non-element child');\r\n          }\r\n          break;\r\n        }\r\n        case EditType.updateText: {\r\n          const frameIndex = editReader.newTreeIndex(edit);\r\n          const frame = batch.referenceFramesEntry(referenceFrames, frameIndex);\r\n          const siblingIndex = editReader.siblingIndex(edit);\r\n          const textNode = getLogicalChild(parent, childIndexAtCurrentDepth + siblingIndex);\r\n          if (textNode instanceof Text) {\r\n            textNode.textContent = frameReader.textContent(frame);\r\n          } else {\r\n            throw new Error('Cannot set text content on non-text child');\r\n          }\r\n          break;\r\n        }\r\n        case EditType.updateMarkup: {\r\n          const frameIndex = editReader.newTreeIndex(edit);\r\n          const frame = batch.referenceFramesEntry(referenceFrames, frameIndex);\r\n          const siblingIndex = editReader.siblingIndex(edit);\r\n          removeLogicalChild(parent, childIndexAtCurrentDepth + siblingIndex);\r\n          this.insertMarkup(batch, parent, childIndexAtCurrentDepth + siblingIndex, frame);\r\n          break;\r\n        }\r\n        case EditType.stepIn: {\r\n          const siblingIndex = editReader.siblingIndex(edit);\r\n          parent = getLogicalChild(parent, childIndexAtCurrentDepth + siblingIndex);\r\n          currentDepth++;\r\n          childIndexAtCurrentDepth = 0;\r\n          break;\r\n        }\r\n        case EditType.stepOut: {\r\n          parent = getLogicalParent(parent)!;\r\n          currentDepth--;\r\n          childIndexAtCurrentDepth = currentDepth === 0 ? childIndex : 0; // The childIndex is only ever nonzero at zero depth\r\n          break;\r\n        }\r\n        case EditType.permutationListEntry: {\r\n          permutationList = permutationList || [];\r\n          permutationList.push({\r\n            fromSiblingIndex: childIndexAtCurrentDepth + editReader.siblingIndex(edit),\r\n            toSiblingIndex: childIndexAtCurrentDepth + editReader.moveToSiblingIndex(edit),\r\n          });\r\n          break;\r\n        }\r\n        case EditType.permutationListEnd: {\r\n          permuteLogicalChildren(parent, permutationList!);\r\n          permutationList = undefined;\r\n          break;\r\n        }\r\n        default: {\r\n          const unknownType: never = editType; // Compile-time verification that the switch was exhaustive\r\n          throw new Error(`Unknown edit type: ${unknownType}`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private insertFrame(batch: RenderBatch, parent: LogicalElement, childIndex: number, frames: ArrayValues<RenderTreeFrame>, frame: RenderTreeFrame, frameIndex: number): number {\r\n    const frameReader = batch.frameReader;\r\n    const frameType = frameReader.frameType(frame);\r\n    switch (frameType) {\r\n      case FrameType.element:\r\n        this.insertElement(batch, parent, childIndex, frames, frame, frameIndex);\r\n        return 1;\r\n      case FrameType.text:\r\n        this.insertText(batch, parent, childIndex, frame);\r\n        return 1;\r\n      case FrameType.attribute:\r\n        throw new Error('Attribute frames should only be present as leading children of element frames.');\r\n      case FrameType.component:\r\n        this.insertComponent(batch, parent, childIndex, frame);\r\n        return 1;\r\n      case FrameType.region:\r\n        return this.insertFrameRange(batch, parent, childIndex, frames, frameIndex + 1, frameIndex + frameReader.subtreeLength(frame));\r\n      case FrameType.elementReferenceCapture:\r\n        if (parent instanceof Element) {\r\n          applyCaptureIdToElement(parent, frameReader.elementReferenceCaptureId(frame)!);\r\n          return 0; // A \"capture\" is a child in the diff, but has no node in the DOM\r\n        } else {\r\n          throw new Error('Reference capture frames can only be children of element frames.');\r\n        }\r\n      case FrameType.markup:\r\n        this.insertMarkup(batch, parent, childIndex, frame);\r\n        return 1;\r\n      default:\r\n        const unknownType: never = frameType; // Compile-time verification that the switch was exhaustive\r\n        throw new Error(`Unknown frame type: ${unknownType}`);\r\n    }\r\n  }\r\n\r\n  private insertElement(batch: RenderBatch, parent: LogicalElement, childIndex: number, frames: ArrayValues<RenderTreeFrame>, frame: RenderTreeFrame, frameIndex: number) {\r\n    const frameReader = batch.frameReader;\r\n    const tagName = frameReader.elementName(frame)!;\r\n    const newDomElementRaw = tagName === 'svg' || isSvgElement(parent) ?\r\n      document.createElementNS('http://www.w3.org/2000/svg', tagName) :\r\n      document.createElement(tagName);\r\n    const newElement = toLogicalElement(newDomElementRaw);\r\n    insertLogicalChild(newDomElementRaw, parent, childIndex);\r\n\r\n    // Apply attributes\r\n    const descendantsEndIndexExcl = frameIndex + frameReader.subtreeLength(frame);\r\n    for (let descendantIndex = frameIndex + 1; descendantIndex < descendantsEndIndexExcl; descendantIndex++) {\r\n      const descendantFrame = batch.referenceFramesEntry(frames, descendantIndex);\r\n      if (frameReader.frameType(descendantFrame) === FrameType.attribute) {\r\n        this.applyAttribute(batch, newDomElementRaw, descendantFrame);\r\n      } else {\r\n        // As soon as we see a non-attribute child, all the subsequent child frames are\r\n        // not attributes, so bail out and insert the remnants recursively\r\n        this.insertFrameRange(batch, newElement, 0, frames, descendantIndex, descendantsEndIndexExcl);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  private insertComponent(batch: RenderBatch, parent: LogicalElement, childIndex: number, frame: RenderTreeFrame) {\r\n    const containerElement = createAndInsertLogicalContainer(parent, childIndex);\r\n\r\n    // All we have to do is associate the child component ID with its location. We don't actually\r\n    // do any rendering here, because the diff for the child will appear later in the render batch.\r\n    const childComponentId = batch.frameReader.componentId(frame);\r\n    this.attachComponentToElement(childComponentId, containerElement);\r\n  }\r\n\r\n  private insertText(batch: RenderBatch, parent: LogicalElement, childIndex: number, textFrame: RenderTreeFrame) {\r\n    const textContent = batch.frameReader.textContent(textFrame)!;\r\n    const newTextNode = document.createTextNode(textContent);\r\n    insertLogicalChild(newTextNode, parent, childIndex);\r\n  }\r\n\r\n  private insertMarkup(batch: RenderBatch, parent: LogicalElement, childIndex: number, markupFrame: RenderTreeFrame) {\r\n    const markupContainer = createAndInsertLogicalContainer(parent, childIndex);\r\n\r\n    const markupContent = batch.frameReader.markupContent(markupFrame);\r\n    const parsedMarkup = parseMarkup(markupContent, isSvgElement(parent));\r\n    let logicalSiblingIndex = 0;\r\n    while (parsedMarkup.firstChild) {\r\n      insertLogicalChild(parsedMarkup.firstChild, markupContainer, logicalSiblingIndex++);\r\n    }\r\n  }\r\n\r\n  private applyAttribute(batch: RenderBatch, toDomElement: Element, attributeFrame: RenderTreeFrame) {\r\n    const frameReader = batch.frameReader;\r\n    const attributeName = frameReader.attributeName(attributeFrame)!;\r\n    const browserRendererId = this.browserRendererId;\r\n    const eventHandlerId = frameReader.attributeEventHandlerId(attributeFrame);\r\n\r\n    if (eventHandlerId) {\r\n      const firstTwoChars = attributeName.substring(0, 2);\r\n      const eventName = attributeName.substring(2);\r\n      if (firstTwoChars !== 'on' || !eventName) {\r\n        throw new Error(`Attribute has nonzero event handler ID, but attribute name '${attributeName}' does not start with 'on'.`);\r\n      }\r\n      this.eventDelegator.setListener(toDomElement, eventName, eventHandlerId);\r\n      return;\r\n    }\r\n\r\n    // First see if we have special handling for this attribute\r\n    if (!this.tryApplySpecialProperty(batch, toDomElement, attributeName, attributeFrame)) {\r\n      // If not, treat it as a regular string-valued attribute\r\n      toDomElement.setAttribute(\r\n        attributeName,\r\n        frameReader.attributeValue(attributeFrame)!\r\n      );\r\n    }\r\n  }\r\n\r\n  private tryApplySpecialProperty(batch: RenderBatch, element: Element, attributeName: string, attributeFrame: RenderTreeFrame | null) {\r\n    switch (attributeName) {\r\n      case 'value':\r\n        return this.tryApplyValueProperty(batch, element, attributeFrame);\r\n      case 'checked':\r\n        return this.tryApplyCheckedProperty(batch, element, attributeFrame);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private tryApplyValueProperty(batch: RenderBatch, element: Element, attributeFrame: RenderTreeFrame | null) {\r\n    // Certain elements have built-in behaviour for their 'value' property\r\n    const frameReader = batch.frameReader;\r\n    switch (element.tagName) {\r\n      case 'INPUT':\r\n      case 'SELECT':\r\n      case 'TEXTAREA': {\r\n        const value = attributeFrame ? frameReader.attributeValue(attributeFrame) : null;\r\n        (element as any).value = value;\r\n\r\n        if (element.tagName === 'SELECT') {\r\n          // <select> is special, in that anything we write to .value will be lost if there\r\n          // isn't yet a matching <option>. To maintain the expected behavior no matter the\r\n          // element insertion/update order, preserve the desired value separately so\r\n          // we can recover it when inserting any matching <option>.\r\n          element[selectValuePropname] = value;\r\n        }\r\n        return true;\r\n      }\r\n      case 'OPTION': {\r\n        const value = attributeFrame ? frameReader.attributeValue(attributeFrame) : null;\r\n        if (value) {\r\n          element.setAttribute('value', value);\r\n        } else {\r\n          element.removeAttribute('value');\r\n        }\r\n        // See above for why we have this special handling for <select>/<option>\r\n        const parentElement = element.parentElement;\r\n        if (parentElement && (selectValuePropname in parentElement) && parentElement[selectValuePropname] === value) {\r\n          this.tryApplyValueProperty(batch, parentElement, attributeFrame);\r\n          delete parentElement[selectValuePropname];\r\n        }\r\n        return true;\r\n      }\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  private tryApplyCheckedProperty(batch: RenderBatch, element: Element, attributeFrame: RenderTreeFrame | null) {\r\n    // Certain elements have built-in behaviour for their 'checked' property\r\n    if (element.tagName === 'INPUT') {\r\n      const value = attributeFrame ? batch.frameReader.attributeValue(attributeFrame) : null;\r\n      (element as any).checked = value !== null;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private insertFrameRange(batch: RenderBatch, parent: LogicalElement, childIndex: number, frames: ArrayValues<RenderTreeFrame>, startIndex: number, endIndexExcl: number): number {\r\n    const origChildIndex = childIndex;\r\n    for (let index = startIndex; index < endIndexExcl; index++) {\r\n      const frame = batch.referenceFramesEntry(frames, index);\r\n      const numChildrenInserted = this.insertFrame(batch, parent, childIndex, frames, frame, index);\r\n      childIndex += numChildrenInserted;\r\n\r\n      // Skip over any descendants, since they are already dealt with recursively\r\n      index += countDescendantFrames(batch, frame);\r\n    }\r\n\r\n    return (childIndex - origChildIndex); // Total number of children inserted\r\n  }\r\n}\r\n\r\nexport interface ComponentDescriptor {\r\n  start: Node;\r\n  end: Node;\r\n}\r\n\r\nfunction parseMarkup(markup: string, isSvg: boolean) {\r\n  if (isSvg) {\r\n    sharedSvgElemForParsing.innerHTML = markup || ' ';\r\n    return sharedSvgElemForParsing;\r\n  } else {\r\n    sharedTemplateElemForParsing.innerHTML = markup || ' ';\r\n    return sharedTemplateElemForParsing.content;\r\n  }\r\n}\r\n\r\nfunction countDescendantFrames(batch: RenderBatch, frame: RenderTreeFrame): number {\r\n  const frameReader = batch.frameReader;\r\n  switch (frameReader.frameType(frame)) {\r\n    // The following frame types have a subtree length. Other frames may use that memory slot\r\n    // to mean something else, so we must not read it. We should consider having nominal subtypes\r\n    // of RenderTreeFramePointer that prevent access to non-applicable fields.\r\n    case FrameType.component:\r\n    case FrameType.element:\r\n    case FrameType.region:\r\n      return frameReader.subtreeLength(frame) - 1;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\nfunction raiseEvent(event: Event, browserRendererId: number, eventHandlerId: number, eventArgs: EventForDotNet<UIEventArgs>) {\r\n  if (preventDefaultEvents[event.type]) {\r\n    event.preventDefault();\r\n  }\r\n\r\n  const eventDescriptor = {\r\n    browserRendererId,\r\n    eventHandlerId,\r\n    eventArgsType: eventArgs.type,\r\n  };\r\n\r\n  return DotNet.invokeMethodAsync(\r\n    'Microsoft.AspNetCore.Components.Browser',\r\n    'DispatchEvent',\r\n    eventDescriptor,\r\n    JSON.stringify(eventArgs.data)\r\n  );\r\n}\r\n\r\nfunction clearElement(element: Element) {\r\n  let childNode: Node | null;\r\n  while (childNode = element.firstChild) {\r\n    element.removeChild(childNode);\r\n  }\r\n}\r\n\r\nfunction clearBetween(start: Node, end: Node): void {\r\n  const logicalParent = getLogicalParent(start as unknown as LogicalElement);\r\n  if (!logicalParent){\r\n    throw new Error(\"Can't clear between nodes. The start node does not have a logical parent.\");\r\n  }\r\n  const children = getLogicalChildrenArray(logicalParent);\r\n  const removeStart = children.indexOf(start as unknown as LogicalElement) + 1;\r\n  const endIndex = children.indexOf(end as unknown as LogicalElement);\r\n\r\n  // We remove the end component comment from the DOM as we don't need it after this point.\r\n  for (let i = removeStart; i <= endIndex; i++) {\r\n    removeLogicalChild(logicalParent, removeStart);\r\n  }\r\n\r\n  // We sanitize the start comment by removing all the information from it now that we don't need it anymore\r\n  // as it adds noise to the DOM.\r\n  start.textContent = '!';\r\n}\r\n","export function applyCaptureIdToElement(element: Element, referenceCaptureId: string) {\r\n  element.setAttribute(getCaptureIdAttributeName(referenceCaptureId), '');\r\n}\r\n\r\nfunction getElementByCaptureId(referenceCaptureId: string) {\r\n  const selector = `[${getCaptureIdAttributeName(referenceCaptureId)}]`;\r\n  return document.querySelector(selector);\r\n}\r\n\r\nfunction getCaptureIdAttributeName(referenceCaptureId: string) {\r\n  return `_bl_${referenceCaptureId}`;\r\n}\r\n\r\n// Support receiving ElementRef instances as args in interop calls\r\nconst elementRefKey = '__internalId'; // Keep in sync with ElementRef.cs\r\nDotNet.attachReviver((key, value) => {\r\n  if (value && typeof value === 'object' && value.hasOwnProperty(elementRefKey) && typeof value[elementRefKey] === 'string') {\r\n    return getElementByCaptureId(value[elementRefKey]);\r\n  } else {\r\n    return value;\r\n  }\r\n});\r\n","import { EventForDotNet, UIEventArgs } from './EventForDotNet';\r\n\r\nconst nonBubblingEvents = toLookup([\r\n  'abort',\r\n  'blur',\r\n  'change',\r\n  'error',\r\n  'focus',\r\n  'load',\r\n  'loadend',\r\n  'loadstart',\r\n  'mouseenter',\r\n  'mouseleave',\r\n  'progress',\r\n  'reset',\r\n  'scroll',\r\n  'submit',\r\n  'unload',\r\n  'DOMNodeInsertedIntoDocument',\r\n  'DOMNodeRemovedFromDocument',\r\n]);\r\n\r\nexport interface OnEventCallback {\r\n  (event: Event, eventHandlerId: number, eventArgs: EventForDotNet<UIEventArgs>): void;\r\n}\r\n\r\n// Responsible for adding/removing the eventInfo on an expando property on DOM elements, and\r\n// calling an EventInfoStore that deals with registering/unregistering the underlying delegated\r\n// event listeners as required (and also maps actual events back to the given callback).\r\nexport class EventDelegator {\r\n  private static nextEventDelegatorId = 0;\r\n\r\n  private eventsCollectionKey: string;\r\n\r\n  private eventInfoStore: EventInfoStore;\r\n\r\n  constructor(private onEvent: OnEventCallback) {\r\n    const eventDelegatorId = ++EventDelegator.nextEventDelegatorId;\r\n    this.eventsCollectionKey = `_blazorEvents_${eventDelegatorId}`;\r\n    this.eventInfoStore = new EventInfoStore(this.onGlobalEvent.bind(this));\r\n  }\r\n\r\n  public setListener(element: Element, eventName: string, eventHandlerId: number) {\r\n    // Ensure we have a place to store event info for this element\r\n    let infoForElement: EventHandlerInfosForElement = element[this.eventsCollectionKey];\r\n    if (!infoForElement) {\r\n      infoForElement = element[this.eventsCollectionKey] = {};\r\n    }\r\n\r\n    if (infoForElement.hasOwnProperty(eventName)) {\r\n      // We can cheaply update the info on the existing object and don't need any other housekeeping\r\n      const oldInfo = infoForElement[eventName];\r\n      this.eventInfoStore.update(oldInfo.eventHandlerId, eventHandlerId);\r\n    } else {\r\n      // Go through the whole flow which might involve registering a new global handler\r\n      const newInfo = { element, eventName, eventHandlerId };\r\n      this.eventInfoStore.add(newInfo);\r\n      infoForElement[eventName] = newInfo;\r\n    }\r\n  }\r\n\r\n  public removeListener(eventHandlerId: number) {\r\n    // This method gets called whenever the .NET-side code reports that a certain event handler\r\n    // has been disposed. However we will already have disposed the info about that handler if\r\n    // the eventHandlerId for the (element,eventName) pair was replaced during diff application.\r\n    const info = this.eventInfoStore.remove(eventHandlerId);\r\n    if (info) {\r\n      // Looks like this event handler wasn't already disposed\r\n      // Remove the associated data from the DOM element\r\n      const element = info.element;\r\n      if (element.hasOwnProperty(this.eventsCollectionKey)) {\r\n        const elementEventInfos: EventHandlerInfosForElement = element[this.eventsCollectionKey];\r\n        delete elementEventInfos[info.eventName];\r\n        if (Object.getOwnPropertyNames(elementEventInfos).length === 0) {\r\n          delete element[this.eventsCollectionKey];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private onGlobalEvent(evt: Event) {\r\n    if (!(evt.target instanceof Element)) {\r\n      return;\r\n    }\r\n\r\n    // Scan up the element hierarchy, looking for any matching registered event handlers\r\n    let candidateElement = evt.target as Element | null;\r\n    let eventArgs: EventForDotNet<UIEventArgs> | null = null; // Populate lazily\r\n    const eventIsNonBubbling = nonBubblingEvents.hasOwnProperty(evt.type);\r\n    while (candidateElement) {\r\n      if (candidateElement.hasOwnProperty(this.eventsCollectionKey)) {\r\n        const handlerInfos = candidateElement[this.eventsCollectionKey];\r\n        if (handlerInfos.hasOwnProperty(evt.type)) {\r\n          // We are going to raise an event for this element, so prepare info needed by the .NET code\r\n          if (!eventArgs) {\r\n            eventArgs = EventForDotNet.fromDOMEvent(evt);\r\n          }\r\n\r\n          const handlerInfo = handlerInfos[evt.type];\r\n          this.onEvent(evt, handlerInfo.eventHandlerId, eventArgs);\r\n        }\r\n      }\r\n\r\n      candidateElement = eventIsNonBubbling ? null : candidateElement.parentElement;\r\n    }\r\n  }\r\n}\r\n\r\n// Responsible for adding and removing the global listener when the number of listeners\r\n// for a given event name changes between zero and nonzero\r\nclass EventInfoStore {\r\n  private infosByEventHandlerId: { [eventHandlerId: number]: EventHandlerInfo } = {};\r\n\r\n  private countByEventName: { [eventName: string]: number } = {};\r\n\r\n  constructor(private globalListener: EventListener) {\r\n  }\r\n\r\n  public add(info: EventHandlerInfo) {\r\n    if (this.infosByEventHandlerId[info.eventHandlerId]) {\r\n      // Should never happen, but we want to know if it does\r\n      throw new Error(`Event ${info.eventHandlerId} is already tracked`);\r\n    }\r\n\r\n    this.infosByEventHandlerId[info.eventHandlerId] = info;\r\n\r\n    const eventName = info.eventName;\r\n    if (this.countByEventName.hasOwnProperty(eventName)) {\r\n      this.countByEventName[eventName]++;\r\n    } else {\r\n      this.countByEventName[eventName] = 1;\r\n\r\n      // To make delegation work with non-bubbling events, register a 'capture' listener.\r\n      // We preserve the non-bubbling behavior by only dispatching such events to the targeted element.\r\n      const useCapture = nonBubblingEvents.hasOwnProperty(eventName);\r\n      document.addEventListener(eventName, this.globalListener, useCapture);\r\n    }\r\n  }\r\n\r\n  public update(oldEventHandlerId: number, newEventHandlerId: number) {\r\n    if (this.infosByEventHandlerId.hasOwnProperty(newEventHandlerId)) {\r\n      // Should never happen, but we want to know if it does\r\n      throw new Error(`Event ${newEventHandlerId} is already tracked`);\r\n    }\r\n\r\n    // Since we're just updating the event handler ID, there's no need to update the global counts\r\n    const info = this.infosByEventHandlerId[oldEventHandlerId];\r\n    delete this.infosByEventHandlerId[oldEventHandlerId];\r\n    info.eventHandlerId = newEventHandlerId;\r\n    this.infosByEventHandlerId[newEventHandlerId] = info;\r\n  }\r\n\r\n  public remove(eventHandlerId: number): EventHandlerInfo {\r\n    const info = this.infosByEventHandlerId[eventHandlerId];\r\n    if (info) {\r\n      delete this.infosByEventHandlerId[eventHandlerId];\r\n\r\n      const eventName = info.eventName;\r\n      if (--this.countByEventName[eventName] === 0) {\r\n        delete this.countByEventName[eventName];\r\n        document.removeEventListener(eventName, this.globalListener);\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n}\r\n\r\ninterface EventHandlerInfosForElement {\r\n  // Although we *could* track multiple event handlers per (element, eventName) pair\r\n  // (since they have distinct eventHandlerId values), there's no point doing so because\r\n  // our programming model is that you declare event handlers as attributes. An element\r\n  // can only have one attribute with a given name, hence only one event handler with\r\n  // that name at any one time.\r\n  // So to keep things simple, only track one EventHandlerInfo per (element, eventName)\r\n  [eventName: string]: EventHandlerInfo;\r\n}\r\n\r\ninterface EventHandlerInfo {\r\n  element: Element;\r\n  eventName: string;\r\n  eventHandlerId: number;\r\n}\r\n\r\nfunction toLookup(items: string[]): { [key: string]: boolean } {\r\n  const result = {};\r\n  items.forEach(value => {\r\n    result[value] = true;\r\n  });\r\n  return result;\r\n}\r\n","export class EventForDotNet<TData extends UIEventArgs> {\r\n  constructor(public readonly type: EventArgsType, public readonly data: TData) {\r\n  }\r\n\r\n  static fromDOMEvent(event: Event): EventForDotNet<UIEventArgs> {\r\n    const element = event.target as Element;\r\n    switch (event.type) {\r\n\r\n      case 'input':\r\n      case 'change': {\r\n        const targetIsCheckbox = isCheckbox(element);\r\n        const newValue = targetIsCheckbox ? !!element['checked'] : element['value'];\r\n        return new EventForDotNet<UIChangeEventArgs>('change', { type: event.type, value: newValue });\r\n      }\r\n\r\n      case 'copy':\r\n      case 'cut':\r\n      case 'paste':\r\n        return new EventForDotNet<UIClipboardEventArgs>('clipboard', { type: event.type });\r\n\r\n      case 'drag':\r\n      case 'dragend':\r\n      case 'dragenter':\r\n      case 'dragleave':\r\n      case 'dragover':\r\n      case 'dragstart':\r\n      case 'drop':\r\n        return new EventForDotNet<UIDragEventArgs>('drag', parseDragEvent(event));\r\n\r\n      case 'focus':\r\n      case 'blur':\r\n      case 'focusin':\r\n      case 'focusout':\r\n        return new EventForDotNet<UIFocusEventArgs>('focus', { type: event.type });\r\n\r\n      case 'keydown':\r\n      case 'keyup':\r\n      case 'keypress':\r\n        return new EventForDotNet<UIKeyboardEventArgs>('keyboard', parseKeyboardEvent(<KeyboardEvent>event));\r\n\r\n      case 'contextmenu':\r\n      case 'click':\r\n      case 'mouseover':\r\n      case 'mouseout':\r\n      case 'mousemove':\r\n      case 'mousedown':\r\n      case 'mouseup':\r\n      case 'dblclick':\r\n        return new EventForDotNet<UIMouseEventArgs>('mouse', parseMouseEvent(<MouseEvent>event));\r\n\r\n      case 'error':\r\n        return new EventForDotNet<UIErrorEventArgs>('error', parseErrorEvent(<ErrorEvent>event));\r\n\r\n      case 'loadstart':\r\n      case 'timeout':\r\n      case 'abort':\r\n      case 'load':\r\n      case 'loadend':\r\n      case 'progress':\r\n        return new EventForDotNet<UIProgressEventArgs>('progress', parseProgressEvent(<ProgressEvent>event));\r\n\r\n      case 'touchcancel':\r\n      case 'touchend':\r\n      case 'touchmove':\r\n      case 'touchenter':\r\n      case 'touchleave':\r\n      case 'touchstart':\r\n        return new EventForDotNet<UITouchEventArgs>('touch', parseTouchEvent(<TouchEvent>event));\r\n\r\n      case 'gotpointercapture':\r\n      case 'lostpointercapture':\r\n      case 'pointercancel':\r\n      case 'pointerdown':\r\n      case 'pointerenter':\r\n      case 'pointerleave':\r\n      case 'pointermove':\r\n      case 'pointerout':\r\n      case 'pointerover':\r\n      case 'pointerup':\r\n        return new EventForDotNet<UIPointerEventArgs>('pointer', parsePointerEvent(<PointerEvent>event));\r\n\r\n      case 'wheel':\r\n      case 'mousewheel':\r\n        return new EventForDotNet<UIWheelEventArgs>('wheel', parseWheelEvent(<WheelEvent>event));\r\n\r\n      default:\r\n        return new EventForDotNet<UIEventArgs>('unknown', { type: event.type });\r\n    }\r\n  }\r\n}\r\n\r\nfunction parseDragEvent(event: any) {\r\n  return {\r\n    ...parseMouseEvent(event),\r\n    dataTransfer: event.dataTransfer,\r\n\r\n  };\r\n}\r\n\r\nfunction parseWheelEvent(event: WheelEvent) {\r\n  return {\r\n    ...parseMouseEvent(event),\r\n    deltaX: event.deltaX,\r\n    deltaY: event.deltaY,\r\n    deltaZ: event.deltaZ,\r\n    deltaMode: event.deltaMode,\r\n  };\r\n}\r\n\r\nfunction parseErrorEvent(event: ErrorEvent) {\r\n  return {\r\n    type: event.type,\r\n    message: event.message,\r\n    filename: event.filename,\r\n    lineno: event.lineno,\r\n    colno: event.colno,\r\n  };\r\n}\r\n\r\nfunction parseProgressEvent(event: ProgressEvent) {\r\n  return {\r\n    type: event.type,\r\n    lengthComputable: event.lengthComputable,\r\n    loaded: event.loaded,\r\n    total: event.total,\r\n  };\r\n}\r\n\r\nfunction parseTouchEvent(event: TouchEvent) {\r\n\r\n  function parseTouch(touchList: TouchList) {\r\n    const touches: UITouchPoint[] = [];\r\n\r\n    for (let i = 0; i < touchList.length; i++) {\r\n      const touch = touchList[i];\r\n      touches.push({\r\n        identifier: touch.identifier,\r\n        clientX: touch.clientX,\r\n        clientY: touch.clientY,\r\n        screenX: touch.screenX,\r\n        screenY: touch.screenY,\r\n        pageX: touch.pageX,\r\n        pageY: touch.pageY,\r\n      });\r\n    }\r\n    return touches;\r\n  }\r\n\r\n  return {\r\n    type: event.type,\r\n    detail: event.detail,\r\n    touches: parseTouch(event.touches),\r\n    targetTouches: parseTouch(event.targetTouches),\r\n    changedTouches: parseTouch(event.changedTouches),\r\n    ctrlKey: event.ctrlKey,\r\n    shiftKey: event.shiftKey,\r\n    altKey: event.altKey,\r\n    metaKey: event.metaKey,\r\n  };\r\n}\r\n\r\nfunction parseKeyboardEvent(event: KeyboardEvent) {\r\n  return {\r\n    type: event.type,\r\n    key: event.key,\r\n    code: event.code,\r\n    location: event.location,\r\n    repeat: event.repeat,\r\n    ctrlKey: event.ctrlKey,\r\n    shiftKey: event.shiftKey,\r\n    altKey: event.altKey,\r\n    metaKey: event.metaKey,\r\n  };\r\n}\r\n\r\nfunction parsePointerEvent(event: PointerEvent) {\r\n  return {\r\n    ...parseMouseEvent(event),\r\n    pointerId: event.pointerId,\r\n    width: event.width,\r\n    height: event.height,\r\n    pressure: event.pressure,\r\n    tiltX: event.tiltX,\r\n    tiltY: event.tiltY,\r\n    pointerType: event.pointerType,\r\n    isPrimary: event.isPrimary,\r\n  };\r\n}\r\n\r\nfunction parseMouseEvent(event: MouseEvent) {\r\n  return {\r\n    type: event.type,\r\n    detail: event.detail,\r\n    screenX: event.screenX,\r\n    screenY: event.screenY,\r\n    clientX: event.clientX,\r\n    clientY: event.clientY,\r\n    button: event.button,\r\n    buttons: event.buttons,\r\n    ctrlKey: event.ctrlKey,\r\n    shiftKey: event.shiftKey,\r\n    altKey: event.altKey,\r\n    metaKey: event.metaKey,\r\n  };\r\n}\r\n\r\nfunction isCheckbox(element: Element | null) {\r\n  return element && element.tagName === 'INPUT' && element.getAttribute('type') === 'checkbox';\r\n}\r\n\r\n// The following interfaces must be kept in sync with the UIEventArgs C# classes\r\n\r\ntype EventArgsType = 'change' | 'clipboard' | 'drag' | 'error' | 'focus' | 'keyboard' | 'mouse' | 'pointer' | 'progress' | 'touch' | 'unknown' | 'wheel';\r\n\r\nexport interface UIEventArgs {\r\n  type: string;\r\n}\r\n\r\ninterface UIChangeEventArgs extends UIEventArgs {\r\n  value: string | boolean;\r\n}\r\n\r\ninterface UIClipboardEventArgs extends UIEventArgs {\r\n}\r\n\r\ninterface UIDragEventArgs extends UIEventArgs {\r\n  detail: number;\r\n  dataTransfer: UIDataTransfer;\r\n  screenX: number;\r\n  screenY: number;\r\n  clientX: number;\r\n  clientY: number;\r\n  button: number;\r\n  buttons: number;\r\n  ctrlKey: boolean;\r\n  shiftKey: boolean;\r\n  altKey: boolean;\r\n  metaKey: boolean;\r\n}\r\n\r\ninterface UIDataTransfer {\r\n  dropEffect: string;\r\n  effectAllowed: string;\r\n  files: string[];\r\n  items: UIDataTransferItem[];\r\n  types: string[];\r\n}\r\n\r\ninterface UIDataTransferItem {\r\n  kind: string;\r\n  type: string;\r\n}\r\n\r\ninterface UIErrorEventArgs extends UIEventArgs {\r\n  message: string;\r\n  filename: string;\r\n  lineno: number;\r\n  colno: number;\r\n\r\n  // omitting 'error' here since we'd have to serialize it, and it's not clear we will want to\r\n  // do that. https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\r\n}\r\n\r\ninterface UIFocusEventArgs extends UIEventArgs {\r\n}\r\n\r\ninterface UIKeyboardEventArgs extends UIEventArgs {\r\n  key: string;\r\n  code: string;\r\n  location: number;\r\n  repeat: boolean;\r\n  ctrlKey: boolean;\r\n  shiftKey: boolean;\r\n  altKey: boolean;\r\n  metaKey: boolean;\r\n}\r\n\r\ninterface UIMouseEventArgs extends UIEventArgs {\r\n  detail: number;\r\n  screenX: number;\r\n  screenY: number;\r\n  clientX: number;\r\n  clientY: number;\r\n  button: number;\r\n  buttons: number;\r\n  ctrlKey: boolean;\r\n  shiftKey: boolean;\r\n  altKey: boolean;\r\n  metaKey: boolean;\r\n}\r\n\r\ninterface UIPointerEventArgs extends UIMouseEventArgs {\r\n  pointerId: number;\r\n  width: number;\r\n  height: number;\r\n  pressure: number;\r\n  tiltX: number;\r\n  tiltY: number;\r\n  pointerType: string;\r\n  isPrimary: boolean;\r\n}\r\n\r\ninterface UIProgressEventArgs extends UIEventArgs {\r\n  lengthComputable: boolean;\r\n  loaded: number;\r\n  total: number;\r\n}\r\n\r\ninterface UITouchEventArgs extends UIEventArgs {\r\n  detail: number;\r\n  touches: UITouchPoint[];\r\n  targetTouches: UITouchPoint[];\r\n  changedTouches: UITouchPoint[];\r\n  ctrlKey: boolean;\r\n  shiftKey: boolean;\r\n  altKey: boolean;\r\n  metaKey: boolean;\r\n}\r\n\r\ninterface UITouchPoint {\r\n  identifier: number;\r\n  screenX: number;\r\n  screenY: number;\r\n  clientX: number;\r\n  clientY: number;\r\n  pageX: number;\r\n  pageY: number;\r\n}\r\n\r\ninterface UIWheelEventArgs extends UIMouseEventArgs {\r\n  deltaX: number;\r\n  deltaY: number;\r\n  deltaZ: number;\r\n  deltaMode: number;\r\n}\r\n","/*\r\n  A LogicalElement plays the same role as an Element instance from the point of view of the\r\n  API consumer. Inserting and removing logical elements updates the browser DOM just the same.\r\n\r\n  The difference is that, unlike regular DOM mutation APIs, the LogicalElement APIs don't use\r\n  the underlying DOM structure as the data storage for the element hierarchy. Instead, the\r\n  LogicalElement APIs take care of tracking hierarchical relationships separately. The point\r\n  of this is to permit a logical tree structure in which parent/child relationships don't\r\n  have to be materialized in terms of DOM element parent/child relationships. And the reason\r\n  why we want that is so that hierarchies of Blazor components can be tracked even when those\r\n  components' render output need not be a single literal DOM element.\r\n\r\n  Consumers of the API don't need to know about the implementation, but how it's done is:\r\n  - Each LogicalElement is materialized in the DOM as either:\r\n    - A Node instance, for actual Node instances inserted using 'insertLogicalChild' or\r\n      for Element instances promoted to LogicalElement via 'toLogicalElement'\r\n    - A Comment instance, for 'logical container' instances inserted using 'createAndInsertLogicalContainer'\r\n  - Then, on that instance (i.e., the Node or Comment), we store an array of 'logical children'\r\n    instances, e.g.,\r\n      [firstChild, secondChild, thirdChild, ...]\r\n    ... plus we store a reference to the 'logical parent' (if any)\r\n  - The 'logical children' array means we can look up in O(1):\r\n    - The number of logical children (not currently implemented because not required, but trivial)\r\n    - The logical child at any given index\r\n  - Whenever a logical child is added or removed, we update the parent's array of logical children\r\n*/\r\n\r\nconst logicalChildrenPropname = createSymbolOrFallback('_blazorLogicalChildren');\r\nconst logicalParentPropname = createSymbolOrFallback('_blazorLogicalParent');\r\nconst logicalEndSiblingPropname = createSymbolOrFallback('_blazorLogicalEnd');\r\n\r\nexport function toLogicalRootCommentElement(start: Comment, end: Comment): LogicalElement {\r\n  // Now that we support start/end comments as component delimiters we are going to be setting up\r\n  // adding the components rendered output as siblings of the start/end tags (between).\r\n  // For that to work, we need to appropriately configure the parent element to be a logical element\r\n  // with all their children being the child elements.\r\n  // For example, imagine you have\r\n  // <app>\r\n  // <div><p>Static content</p></div>\r\n  // <!-- start component\r\n  // <!-- end component\r\n  // <footer>Some other content</footer>\r\n  // <app>\r\n  // We want the parent element to be something like\r\n  // *app\r\n  // |- *div\r\n  // |- *component\r\n  // |- *footer\r\n  if (!start.parentNode){\r\n    throw new Error(`Comment not connected to the DOM ${start.textContent}`);\r\n  }\r\n\r\n  const parent = start.parentNode;\r\n  const parentLogicalElement = toLogicalElement(parent, /* allow existing contents */ true);\r\n  const children = getLogicalChildrenArray(parentLogicalElement);\r\n  Array.from(parent.childNodes).forEach(n => children.push(n as unknown as LogicalElement));\r\n  start[logicalParentPropname] = parentLogicalElement;\r\n  start[logicalEndSiblingPropname] = end;\r\n  toLogicalElement(end, /* allowExistingcontents */ true);\r\n  return toLogicalElement(start, /* allowExistingContents */ true);\r\n}\r\n\r\nexport function toLogicalElement(element: Node, allowExistingContents?: boolean): LogicalElement {\r\n  // Normally it's good to assert that the element has started empty, because that's the usual\r\n  // situation and we probably have a bug if it's not. But for the element that contain prerendered\r\n  // root components, we want to let them keep their content until we replace it.\r\n  if (element.childNodes.length > 0 && !allowExistingContents) {\r\n    throw new Error('New logical elements must start empty, or allowExistingContents must be true');\r\n  }\r\n\r\n  element[logicalChildrenPropname] = [];\r\n  return element as unknown as LogicalElement;\r\n}\r\n\r\nexport function createAndInsertLogicalContainer(parent: LogicalElement, childIndex: number): LogicalElement {\r\n  const containerElement = document.createComment('!');\r\n  insertLogicalChild(containerElement, parent, childIndex);\r\n  return containerElement as any as LogicalElement;\r\n}\r\n\r\nexport function insertLogicalChild(child: Node, parent: LogicalElement, childIndex: number) {\r\n  const childAsLogicalElement = child as any as LogicalElement;\r\n  if (child instanceof Comment) {\r\n    const existingGrandchildren = getLogicalChildrenArray(childAsLogicalElement);\r\n    if (existingGrandchildren && getLogicalChildrenArray(childAsLogicalElement).length > 0) {\r\n      // There's nothing to stop us implementing support for this scenario, and it's not difficult\r\n      // (after inserting 'child' itself, also iterate through its logical children and physically\r\n      // put them as following-siblings in the DOM). However there's no scenario that requires it\r\n      // presently, so if we did implement it there'd be no good way to have tests for it.\r\n      throw new Error('Not implemented: inserting non-empty logical container');\r\n    }\r\n  }\r\n\r\n  if (getLogicalParent(childAsLogicalElement)) {\r\n    // Likewise, we could easily support this scenario too (in this 'if' block, just splice\r\n    // out 'child' from the logical children array of its previous logical parent by using\r\n    // Array.prototype.indexOf to determine its previous sibling index).\r\n    // But again, since there's not currently any scenario that would use it, we would not\r\n    // have any test coverage for such an implementation.\r\n    throw new Error('Not implemented: moving existing logical children');\r\n  }\r\n\r\n  const newSiblings = getLogicalChildrenArray(parent);\r\n  if (childIndex < newSiblings.length) {\r\n    // Insert\r\n    const nextSibling = newSiblings[childIndex] as any as Node;\r\n    nextSibling.parentNode!.insertBefore(child, nextSibling);\r\n    newSiblings.splice(childIndex, 0, childAsLogicalElement);\r\n  } else {\r\n    // Append\r\n    appendDomNode(child, parent);\r\n    newSiblings.push(childAsLogicalElement);\r\n  }\r\n\r\n  childAsLogicalElement[logicalParentPropname] = parent;\r\n  if (!(logicalChildrenPropname in childAsLogicalElement)) {\r\n    childAsLogicalElement[logicalChildrenPropname] = [];\r\n  }\r\n}\r\n\r\nexport function removeLogicalChild(parent: LogicalElement, childIndex: number) {\r\n  const childrenArray = getLogicalChildrenArray(parent);\r\n  const childToRemove = childrenArray.splice(childIndex, 1)[0];\r\n\r\n  // If it's a logical container, also remove its descendants\r\n  if (childToRemove instanceof Comment) {\r\n    const grandchildrenArray = getLogicalChildrenArray(childToRemove);\r\n    while (grandchildrenArray.length > 0) {\r\n      removeLogicalChild(childToRemove, 0);\r\n    }\r\n  }\r\n\r\n  // Finally, remove the node itself\r\n  const domNodeToRemove = childToRemove as any as Node;\r\n  domNodeToRemove.parentNode!.removeChild(domNodeToRemove);\r\n}\r\n\r\nexport function getLogicalParent(element: LogicalElement): LogicalElement | null {\r\n  return (element[logicalParentPropname] as LogicalElement) || null;\r\n}\r\n\r\nexport function getLogicalSiblingEnd(element: LogicalElement): LogicalElement | null {\r\n  return (element[logicalEndSiblingPropname] as LogicalElement) || null;\r\n}\r\n\r\nexport function getLogicalChild(parent: LogicalElement, childIndex: number): LogicalElement {\r\n  return getLogicalChildrenArray(parent)[childIndex];\r\n}\r\n\r\nexport function isSvgElement(element: LogicalElement) {\r\n  return getClosestDomElement(element).namespaceURI === 'http://www.w3.org/2000/svg';\r\n}\r\n\r\nexport function getLogicalChildrenArray(element: LogicalElement) {\r\n  return element[logicalChildrenPropname] as LogicalElement[];\r\n}\r\n\r\nexport function permuteLogicalChildren(parent: LogicalElement, permutationList: PermutationListEntry[]) {\r\n  // The permutationList must represent a valid permutation, i.e., the list of 'from' indices\r\n  // is distinct, and the list of 'to' indices is a permutation of it. The algorithm here\r\n  // relies on that assumption.\r\n\r\n  // Each of the phases here has to happen separately, because each one is designed not to\r\n  // interfere with the indices or DOM entries used by subsequent phases.\r\n\r\n  // Phase 1: track which nodes we will move\r\n  const siblings = getLogicalChildrenArray(parent);\r\n  permutationList.forEach((listEntry: PermutationListEntryWithTrackingData) => {\r\n    listEntry.moveRangeStart = siblings[listEntry.fromSiblingIndex];\r\n    listEntry.moveRangeEnd = findLastDomNodeInRange(listEntry.moveRangeStart);\r\n  });\r\n\r\n  // Phase 2: insert markers\r\n  permutationList.forEach((listEntry: PermutationListEntryWithTrackingData) => {\r\n    const marker = listEntry.moveToBeforeMarker = document.createComment('marker');\r\n    const insertBeforeNode = siblings[listEntry.toSiblingIndex + 1] as any as Node;\r\n    if (insertBeforeNode) {\r\n      insertBeforeNode.parentNode!.insertBefore(marker, insertBeforeNode);\r\n    } else {\r\n      appendDomNode(marker, parent);\r\n    }\r\n  });\r\n\r\n  // Phase 3: move descendants & remove markers\r\n  permutationList.forEach((listEntry: PermutationListEntryWithTrackingData) => {\r\n    const insertBefore = listEntry.moveToBeforeMarker!;\r\n    const parentDomNode = insertBefore.parentNode!;\r\n    const elementToMove = listEntry.moveRangeStart!;\r\n    const moveEndNode = listEntry.moveRangeEnd!;\r\n    let nextToMove = elementToMove as any as Node | null;\r\n    while (nextToMove) {\r\n      const nextNext = nextToMove.nextSibling;\r\n      parentDomNode.insertBefore(nextToMove, insertBefore);\r\n\r\n      if (nextToMove === moveEndNode) {\r\n        break;\r\n      } else {\r\n        nextToMove = nextNext;\r\n      }\r\n    }\r\n\r\n    parentDomNode.removeChild(insertBefore);\r\n  });\r\n\r\n  // Phase 4: update siblings index\r\n  permutationList.forEach((listEntry: PermutationListEntryWithTrackingData) => {\r\n    siblings[listEntry.toSiblingIndex] = listEntry.moveRangeStart!;\r\n  });\r\n}\r\n\r\nexport function getClosestDomElement(logicalElement: LogicalElement) {\r\n  if (logicalElement instanceof Element) {\r\n    return logicalElement;\r\n  } else if (logicalElement instanceof Comment) {\r\n    return logicalElement.parentNode! as Element;\r\n  } else {\r\n    throw new Error('Not a valid logical element');\r\n  }\r\n}\r\n\r\nexport interface PermutationListEntry {\r\n  fromSiblingIndex: number,\r\n  toSiblingIndex: number,\r\n}\r\n\r\ninterface PermutationListEntryWithTrackingData extends PermutationListEntry {\r\n  // These extra properties are used internally when processing the permutation list\r\n  moveRangeStart?: LogicalElement,\r\n  moveRangeEnd?: Node,\r\n  moveToBeforeMarker?: Node,\r\n}\r\n\r\nfunction getLogicalNextSibling(element: LogicalElement): LogicalElement | null {\r\n  const siblings = getLogicalChildrenArray(getLogicalParent(element)!);\r\n  const siblingIndex = Array.prototype.indexOf.call(siblings, element);\r\n  return siblings[siblingIndex + 1] || null;\r\n}\r\n\r\nfunction appendDomNode(child: Node, parent: LogicalElement) {\r\n  // This function only puts 'child' into the DOM in the right place relative to 'parent'\r\n  // It does not update the logical children array of anything\r\n  if (parent instanceof Element) {\r\n    parent.appendChild(child);\r\n  } else if (parent instanceof Comment) {\r\n    const parentLogicalNextSibling = getLogicalNextSibling(parent) as any as Node;\r\n    if (parentLogicalNextSibling) {\r\n      // Since the parent has a logical next-sibling, its appended child goes right before that\r\n      parentLogicalNextSibling.parentNode!.insertBefore(child, parentLogicalNextSibling);\r\n    } else {\r\n      // Since the parent has no logical next-sibling, keep recursing upwards until we find\r\n      // a logical ancestor that does have a next-sibling or is a physical element.\r\n      appendDomNode(child, getLogicalParent(parent)!);\r\n    }\r\n  } else {\r\n    // Should never happen\r\n    throw new Error(`Cannot append node because the parent is not a valid logical element. Parent: ${parent}`);\r\n  }\r\n}\r\n\r\n// Returns the final node (in depth-first evaluation order) that is a descendant of the logical element.\r\n// As such, the entire subtree is between 'element' and 'findLastDomNodeInRange(element)' inclusive.\r\nfunction findLastDomNodeInRange(element: LogicalElement) {\r\n  if (element instanceof Element) {\r\n    return element;\r\n  }\r\n\r\n  const nextSibling = getLogicalNextSibling(element);\r\n  if (nextSibling) {\r\n    // Simple case: not the last logical sibling, so take the node before the next sibling\r\n    return (nextSibling as any as Node).previousSibling;\r\n  } else {\r\n    // Harder case: there's no logical next-sibling, so recurse upwards until we find\r\n    // a logical ancestor that does have one, or a physical element\r\n    const logicalParent = getLogicalParent(element)!;\r\n    return logicalParent instanceof Element\r\n      ? logicalParent.lastChild\r\n      : findLastDomNodeInRange(logicalParent);\r\n  }\r\n}\r\n\r\nfunction createSymbolOrFallback(fallback: string): symbol | string {\r\n  return typeof Symbol === 'function' ? Symbol() : fallback;\r\n}\r\n\r\n// Nominal type to represent a logical element without needing to allocate any object for instances\r\nexport interface LogicalElement { LogicalElement__DO_NOT_IMPLEMENT: any }\r\n","import { RenderBatch, ArrayRange, RenderTreeDiff, ArrayValues, RenderTreeEdit, EditType, FrameType, RenderTreeFrame, RenderTreeDiffReader, RenderTreeFrameReader, RenderTreeEditReader, ArrayRangeReader, ArraySegmentReader, ArraySegment } from './RenderBatch';\r\nimport { decodeUtf8 } from './Utf8Decoder';\r\n\r\nconst updatedComponentsEntryLength = 4; // Each is a single int32 giving the location of the data\r\nconst referenceFramesEntryLength = 16; // 1 byte for frame type, then 3 bytes for type-specific data\r\nconst disposedComponentIdsEntryLength = 4; // Each is an int32 giving the ID\r\nconst disposedEventHandlerIdsEntryLength = 4; // Each is an int32 giving the ID\r\nconst editsEntryLength = 16; // 4 ints\r\nconst stringTableEntryLength = 4; // Each is an int32 giving the string data location, or -1 for null\r\n\r\nexport class OutOfProcessRenderBatch implements RenderBatch {\r\n  constructor(private batchData: Uint8Array) {\r\n    const stringReader = new OutOfProcessStringReader(batchData);\r\n\r\n    this.arrayRangeReader = new OutOfProcessArrayRangeReader(batchData);\r\n    this.arraySegmentReader = new OutOfProcessArraySegmentReader(batchData);\r\n    this.diffReader = new OutOfProcessRenderTreeDiffReader(batchData);\r\n    this.editReader = new OutOfProcessRenderTreeEditReader(batchData, stringReader);\r\n    this.frameReader = new OutOfProcessRenderTreeFrameReader(batchData, stringReader);\r\n  }\r\n\r\n  updatedComponents(): ArrayRange<RenderTreeDiff> {\r\n    return readInt32LE(this.batchData, this.batchData.length - 20); // 5th-from-last int32\r\n  }\r\n\r\n  referenceFrames(): ArrayRange<RenderTreeFrame> {\r\n    return readInt32LE(this.batchData, this.batchData.length - 16); // 4th-from-last int32\r\n  }\r\n\r\n  disposedComponentIds(): ArrayRange<number> {\r\n    return readInt32LE(this.batchData, this.batchData.length - 12); // 3rd-from-last int32\r\n  }\r\n\r\n  disposedEventHandlerIds(): ArrayRange<number> {\r\n    return readInt32LE(this.batchData, this.batchData.length - 8); // 2th-from-last int32\r\n  }\r\n\r\n  updatedComponentsEntry(values: ArrayValues<RenderTreeDiff>, index: number): RenderTreeDiff {\r\n    const tableEntryPos = (values as any) + index * updatedComponentsEntryLength;\r\n    return readInt32LE(this.batchData, tableEntryPos);\r\n  }\r\n\r\n  referenceFramesEntry(values: ArrayValues<RenderTreeFrame>, index: number): RenderTreeFrame {\r\n    return (values as any) + index * referenceFramesEntryLength as any;\r\n  }\r\n\r\n  disposedComponentIdsEntry(values: ArrayValues<number>, index: number): number {\r\n    const entryPos = (values as any) + index * disposedComponentIdsEntryLength;\r\n    return readInt32LE(this.batchData, entryPos);\r\n  }\r\n\r\n  disposedEventHandlerIdsEntry(values: ArrayValues<number>, index: number): number {\r\n    const entryPos = (values as any) + index * disposedEventHandlerIdsEntryLength;\r\n    return readInt32LE(this.batchData, entryPos);\r\n  }\r\n\r\n  diffReader: RenderTreeDiffReader;\r\n\r\n  editReader: RenderTreeEditReader;\r\n\r\n  frameReader: RenderTreeFrameReader;\r\n\r\n  arrayRangeReader: ArrayRangeReader;\r\n\r\n  arraySegmentReader: ArraySegmentReader;\r\n}\r\n\r\nclass OutOfProcessRenderTreeDiffReader implements RenderTreeDiffReader {\r\n  constructor(private batchDataUint8: Uint8Array) {\r\n  }\r\n\r\n  componentId(diff: RenderTreeDiff) {\r\n    // First int32 is componentId\r\n    return readInt32LE(this.batchDataUint8, diff as any);\r\n  }\r\n\r\n  edits(diff: RenderTreeDiff) {\r\n    // Entries data starts after the componentId (which is a 4-byte int)\r\n    return (diff as any + 4);\r\n  }\r\n\r\n  editsEntry(values: ArrayValues<RenderTreeEdit>, index: number) {\r\n    return (values as any) + index * editsEntryLength;\r\n  }\r\n}\r\n\r\nclass OutOfProcessRenderTreeEditReader implements RenderTreeEditReader {\r\n  constructor(private batchDataUint8: Uint8Array, private stringReader: OutOfProcessStringReader) {\r\n  }\r\n\r\n  editType(edit: RenderTreeEdit) {\r\n    return readInt32LE(this.batchDataUint8, edit as any); // 1st int\r\n  }\r\n\r\n  siblingIndex(edit: RenderTreeEdit) {\r\n    return readInt32LE(this.batchDataUint8, edit as any + 4); // 2nd int\r\n  }\r\n\r\n  newTreeIndex(edit: RenderTreeEdit) {\r\n    return readInt32LE(this.batchDataUint8, edit as any + 8); // 3rd int\r\n  }\r\n\r\n  moveToSiblingIndex(edit: RenderTreeEdit) {\r\n    return readInt32LE(this.batchDataUint8, edit as any + 8); // 3rd int\r\n  }\r\n\r\n  removedAttributeName(edit: RenderTreeEdit) {\r\n    const stringIndex = readInt32LE(this.batchDataUint8, edit as any + 12); // 4th int\r\n    return this.stringReader.readString(stringIndex);\r\n  }\r\n}\r\n\r\nclass OutOfProcessRenderTreeFrameReader implements RenderTreeFrameReader {\r\n  constructor(private batchDataUint8: Uint8Array, private stringReader: OutOfProcessStringReader) {\r\n  }\r\n\r\n  // For render frames, the 2nd-4th ints have different meanings depending on frameType.\r\n  // It's the caller's responsibility not to evaluate properties that aren't applicable to the frameType.\r\n\r\n  frameType(frame: RenderTreeFrame) {\r\n    return readInt32LE(this.batchDataUint8, frame as any); // 1st int\r\n  }\r\n\r\n  subtreeLength(frame: RenderTreeFrame) {\r\n    return readInt32LE(this.batchDataUint8, frame as any + 4); // 2nd int\r\n  }\r\n\r\n  elementReferenceCaptureId(frame: RenderTreeFrame) {\r\n    const stringIndex = readInt32LE(this.batchDataUint8, frame as any + 4); // 2nd int\r\n    return this.stringReader.readString(stringIndex);\r\n  }\r\n\r\n  componentId(frame: RenderTreeFrame) {\r\n    return readInt32LE(this.batchDataUint8, frame as any + 8); // 3rd int\r\n  }\r\n\r\n  elementName(frame: RenderTreeFrame) {\r\n    const stringIndex = readInt32LE(this.batchDataUint8, frame as any + 8); // 3rd int\r\n    return this.stringReader.readString(stringIndex);\r\n  }\r\n\r\n  textContent(frame: RenderTreeFrame) {\r\n    const stringIndex = readInt32LE(this.batchDataUint8, frame as any + 4); // 2nd int\r\n    return this.stringReader.readString(stringIndex);\r\n  }\r\n\r\n  markupContent(frame: RenderTreeFrame) {\r\n    const stringIndex = readInt32LE(this.batchDataUint8, frame as any + 4); // 2nd int\r\n    return this.stringReader.readString(stringIndex)!;\r\n  }\r\n\r\n  attributeName(frame: RenderTreeFrame) {\r\n    const stringIndex = readInt32LE(this.batchDataUint8, frame as any + 4); // 2nd int\r\n    return this.stringReader.readString(stringIndex);\r\n  }\r\n\r\n  attributeValue(frame: RenderTreeFrame) {\r\n    const stringIndex = readInt32LE(this.batchDataUint8, frame as any + 8); // 3rd int\r\n    return this.stringReader.readString(stringIndex);\r\n  }\r\n\r\n  attributeEventHandlerId(frame: RenderTreeFrame) {\r\n    return readInt32LE(this.batchDataUint8, frame as any + 12); // 4th int\r\n  }\r\n}\r\n\r\nclass OutOfProcessStringReader {\r\n  private stringTableStartIndex: number;\r\n\r\n  constructor(private batchDataUint8: Uint8Array) {\r\n    // Final int gives start position of the string table\r\n    this.stringTableStartIndex = readInt32LE(batchDataUint8, batchDataUint8.length - 4);\r\n  }\r\n\r\n  readString(index: number): string | null {\r\n    if (index === -1) { // Special value encodes 'null'\r\n      return null;\r\n    } else {\r\n      const stringTableEntryPos = readInt32LE(this.batchDataUint8, this.stringTableStartIndex + index * stringTableEntryLength);\r\n\r\n      // By default, .NET's BinaryWriter gives LEB128-length-prefixed UTF-8 data.\r\n      // This is convenient enough to decode in JavaScript.\r\n      const numUtf8Bytes = readLEB128(this.batchDataUint8, stringTableEntryPos);\r\n      const charsStart = stringTableEntryPos + numLEB128Bytes(numUtf8Bytes);\r\n      const utf8Data = new Uint8Array(\r\n        this.batchDataUint8.buffer,\r\n        this.batchDataUint8.byteOffset + charsStart,\r\n        numUtf8Bytes\r\n      );\r\n      return decodeUtf8(utf8Data);\r\n    }\r\n  }\r\n}\r\n\r\nclass OutOfProcessArrayRangeReader implements ArrayRangeReader {\r\n  constructor(private batchDataUint8: Uint8Array) {\r\n  }\r\n\r\n  count<T>(arrayRange: ArrayRange<T>) {\r\n    // First int is count\r\n    return readInt32LE(this.batchDataUint8, arrayRange as any);\r\n  }\r\n\r\n  values<T>(arrayRange: ArrayRange<T>) {\r\n    // Entries data starts after the 'count' int (i.e., after 4 bytes)\r\n    return arrayRange as any + 4;\r\n  }\r\n}\r\n\r\nclass OutOfProcessArraySegmentReader implements ArraySegmentReader {\r\n  constructor(private batchDataUint8: Uint8Array) {\r\n  }\r\n\r\n  offset<T>(arraySegment: ArraySegment<T>) {\r\n    // Not used by the out-of-process representation of RenderBatch data.\r\n    // This only exists on the ArraySegmentReader for the shared-memory representation.\r\n    return 0;\r\n  }\r\n\r\n  count<T>(arraySegment: ArraySegment<T>) {\r\n    // First int is count\r\n    return readInt32LE(this.batchDataUint8, arraySegment as any);\r\n  }\r\n\r\n  values<T>(arraySegment: ArraySegment<T>): ArrayValues<T> {\r\n    // Entries data starts after the 'count' int (i.e., after 4 bytes)\r\n    return arraySegment as any + 4;\r\n  }\r\n}\r\n\r\nfunction readInt32LE(buffer: Uint8Array, position: number): any {\r\n  return (buffer[position])\r\n    | (buffer[position + 1] << 8)\r\n    | (buffer[position + 2] << 16)\r\n    | (buffer[position + 3] << 24);\r\n}\r\n\r\nfunction readLEB128(buffer: Uint8Array, position: number) {\r\n  let result = 0;\r\n  let shift = 0;\r\n  for (let index = 0; index < 4; index++) {\r\n    const byte = buffer[position + index];\r\n    result |= (byte & 127) << shift;\r\n    if (byte < 128) {\r\n      break;\r\n    }\r\n    shift += 7;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction numLEB128Bytes(value: number) {\r\n  return value < 128 ? 1\r\n    : value < 16384 ? 2\r\n      : value < 2097152 ? 3 : 4;\r\n}\r\n","export interface RenderBatch {\r\n  updatedComponents(): ArrayRange<RenderTreeDiff>;\r\n  referenceFrames(): ArrayRange<RenderTreeFrame>;\r\n  disposedComponentIds(): ArrayRange<number>;\r\n  disposedEventHandlerIds(): ArrayRange<number>;\r\n\r\n  updatedComponentsEntry(values: ArrayValues<RenderTreeDiff>, index: number): RenderTreeDiff;\r\n  referenceFramesEntry(values: ArrayValues<RenderTreeFrame>, index: number): RenderTreeFrame;\r\n  disposedComponentIdsEntry(values: ArrayValues<number>, index: number): number;\r\n  disposedEventHandlerIdsEntry(values: ArrayValues<number>, index: number): number;\r\n\r\n  diffReader: RenderTreeDiffReader;\r\n  editReader: RenderTreeEditReader;\r\n  frameReader: RenderTreeFrameReader;\r\n  arrayRangeReader: ArrayRangeReader;\r\n  arraySegmentReader: ArraySegmentReader;\r\n}\r\n\r\nexport interface ArrayRangeReader {\r\n  count<T>(arrayRange: ArrayRange<T>): number;\r\n  values<T>(arrayRange: ArrayRange<T>): ArrayValues<T>;\r\n}\r\n\r\nexport interface ArraySegmentReader {\r\n  offset<T>(arraySegment: ArraySegment<T>): number;\r\n  count<T>(arraySegment: ArraySegment<T>): number;\r\n  values<T>(arraySegment: ArraySegment<T>): ArrayValues<T>;\r\n}\r\n\r\nexport interface RenderTreeDiffReader {\r\n  componentId(diff: RenderTreeDiff): number;\r\n  edits(diff: RenderTreeDiff): ArraySegment<RenderTreeEdit>;\r\n  editsEntry(values: ArrayValues<RenderTreeEdit>, index: number): RenderTreeEdit;\r\n}\r\n\r\nexport interface RenderTreeEditReader {\r\n  editType(edit: RenderTreeEdit): EditType;\r\n  siblingIndex(edit: RenderTreeEdit): number;\r\n  newTreeIndex(edit: RenderTreeEdit): number;\r\n  moveToSiblingIndex(edit: RenderTreeEdit): number;\r\n  removedAttributeName(edit: RenderTreeEdit): string | null;\r\n}\r\n\r\nexport interface RenderTreeFrameReader {\r\n  frameType(frame: RenderTreeFrame): FrameType;\r\n  subtreeLength(frame: RenderTreeFrame): number;\r\n  elementReferenceCaptureId(frame: RenderTreeFrame): string | null;\r\n  componentId(frame: RenderTreeFrame): number;\r\n  elementName(frame: RenderTreeFrame): string | null;\r\n  textContent(frame: RenderTreeFrame): string | null;\r\n  markupContent(frame: RenderTreeFrame): string;\r\n  attributeName(frame: RenderTreeFrame): string | null;\r\n  attributeValue(frame: RenderTreeFrame): string | null;\r\n  attributeEventHandlerId(frame: RenderTreeFrame): number;\r\n}\r\n\r\nexport interface ArrayRange<T> { ArrayRange__DO_NOT_IMPLEMENT: any }\r\nexport interface ArraySegment<T> { ArraySegment__DO_NOT_IMPLEMENT: any }\r\nexport interface ArrayValues<T> { ArrayValues__DO_NOT_IMPLEMENT: any }\r\n\r\nexport interface RenderTreeDiff { RenderTreeDiff__DO_NOT_IMPLEMENT: any }\r\nexport interface RenderTreeFrame { RenderTreeFrame__DO_NOT_IMPLEMENT: any }\r\nexport interface RenderTreeEdit { RenderTreeEdit__DO_NOT_IMPLEMENT: any }\r\n\r\nexport enum EditType {\r\n  // The values must be kept in sync with the .NET equivalent in RenderTreeEditType.cs\r\n  prependFrame = 1,\r\n  removeFrame = 2,\r\n  setAttribute = 3,\r\n  removeAttribute = 4,\r\n  updateText = 5,\r\n  stepIn = 6,\r\n  stepOut = 7,\r\n  updateMarkup = 8,\r\n  permutationListEntry = 9,\r\n  permutationListEnd = 10,\r\n}\r\n\r\nexport enum FrameType {\r\n  // The values must be kept in sync with the .NET equivalent in RenderTreeFrameType.cs\r\n  element = 1,\r\n  text = 2,\r\n  attribute = 3,\r\n  component = 4,\r\n  region = 5,\r\n  elementReferenceCapture = 6,\r\n  markup = 8,\r\n}\r\n","const nativeDecoder = typeof TextDecoder === 'function'\r\n  ? new TextDecoder('utf-8')\r\n  : null;\r\n\r\nexport const decodeUtf8: (bytes: Uint8Array) => string\r\n  = nativeDecoder ? nativeDecoder.decode.bind(nativeDecoder) : decodeImpl;\r\n\r\n/* !\r\nLogic in decodeImpl is derived from fast-text-encoding\r\nhttps://github.com/samthor/fast-text-encoding\r\n\r\nLicense for fast-text-encoding: Apache 2.0\r\nhttps://github.com/samthor/fast-text-encoding/blob/master/LICENSE\r\n*/\r\n\r\nfunction decodeImpl(bytes: Uint8Array): string {\r\n  let pos = 0;\r\n  const len = bytes.length;\r\n  const out: number[] = [];\r\n  const substrings: string[] = [];\r\n\r\n  while (pos < len) {\r\n    const byte1 = bytes[pos++];\r\n    if (byte1 === 0) {\r\n      break; // NULL\r\n    }\r\n\r\n    if ((byte1 & 0x80) === 0) { // 1-byte\r\n      out.push(byte1);\r\n    } else if ((byte1 & 0xe0) === 0xc0) { // 2-byte\r\n      const byte2 = bytes[pos++] & 0x3f;\r\n      out.push(((byte1 & 0x1f) << 6) | byte2);\r\n    } else if ((byte1 & 0xf0) === 0xe0) {\r\n      const byte2 = bytes[pos++] & 0x3f;\r\n      const byte3 = bytes[pos++] & 0x3f;\r\n      out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\r\n    } else if ((byte1 & 0xf8) === 0xf0) {\r\n      const byte2 = bytes[pos++] & 0x3f;\r\n      const byte3 = bytes[pos++] & 0x3f;\r\n      const byte4 = bytes[pos++] & 0x3f;\r\n\r\n      // this can be > 0xffff, so possibly generate surrogates\r\n      let codepoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\r\n      if (codepoint > 0xffff) {\r\n        // codepoint &= ~0x10000;\r\n        codepoint -= 0x10000;\r\n        out.push((codepoint >>> 10) & 0x3ff | 0xd800);\r\n        codepoint = 0xdc00 | codepoint & 0x3ff;\r\n      }\r\n      out.push(codepoint);\r\n    } else {\r\n      // FIXME: we're ignoring this\r\n    }\r\n\r\n    // As a workaround for https://github.com/samthor/fast-text-encoding/issues/1,\r\n    // make sure the 'out' array never gets too long. When it reaches a limit, we\r\n    // stringify what we have so far and append to a list of outputs.\r\n    if (out.length > 1024) {\r\n      substrings.push(String.fromCharCode.apply(null, out));\r\n      out.length = 0;\r\n    }\r\n  }\r\n\r\n  substrings.push(String.fromCharCode.apply(null, out));\r\n  return substrings.join('');\r\n}\r\n","/* eslint-disable @typescript-eslint/camelcase */\r\nimport { System_Object, System_String, System_Array, MethodHandle, Pointer } from '../Platform/Platform';\r\nimport { platform } from '../Environment';\r\nimport { RenderBatch } from './RenderBatch/RenderBatch';\r\nimport { BrowserRenderer } from './BrowserRenderer';\r\nimport { toLogicalElement, LogicalElement } from './LogicalElements';\r\n\r\ninterface BrowserRendererRegistry {\r\n  [browserRendererId: number]: BrowserRenderer;\r\n}\r\nconst browserRenderers: BrowserRendererRegistry = {};\r\n\r\nexport function attachRootComponentToLogicalElement(browserRendererId: number, logicalElement: LogicalElement, componentId: number): void {\r\n\r\n  let browserRenderer = browserRenderers[browserRendererId];\r\n  if (!browserRenderer) {\r\n    browserRenderer = browserRenderers[browserRendererId] = new BrowserRenderer(browserRendererId);\r\n  }\r\n\r\n  browserRenderer.attachRootComponentToLogicalElement(componentId, logicalElement);\r\n}\r\n\r\nexport function attachRootComponentToElement(browserRendererId: number, elementSelector: string, componentId: number): void {\r\n\r\n  const element = document.querySelector(elementSelector);\r\n  if (!element) {\r\n    throw new Error(`Could not find any element matching selector '${elementSelector}'.`);\r\n  }\r\n\r\n  // 'allowExistingContents' to keep any prerendered content until we do the first client-side render\r\n  attachRootComponentToLogicalElement(browserRendererId, toLogicalElement(element, /* allow existing contents */ true), componentId);\r\n}\r\n\r\nexport function renderBatch(browserRendererId: number, batch: RenderBatch): void {\r\n  const browserRenderer = browserRenderers[browserRendererId];\r\n  if (!browserRenderer) {\r\n    throw new Error(`There is no browser renderer with ID ${browserRendererId}.`);\r\n  }\r\n\r\n  const arrayRangeReader = batch.arrayRangeReader;\r\n  const updatedComponentsRange = batch.updatedComponents();\r\n  const updatedComponentsValues = arrayRangeReader.values(updatedComponentsRange);\r\n  const updatedComponentsLength = arrayRangeReader.count(updatedComponentsRange);\r\n  const referenceFrames = batch.referenceFrames();\r\n  const referenceFramesValues = arrayRangeReader.values(referenceFrames);\r\n  const diffReader = batch.diffReader;\r\n\r\n  for (let i = 0; i < updatedComponentsLength; i++) {\r\n    const diff = batch.updatedComponentsEntry(updatedComponentsValues, i);\r\n    const componentId = diffReader.componentId(diff);\r\n    const edits = diffReader.edits(diff);\r\n    browserRenderer.updateComponent(batch, componentId, edits, referenceFramesValues);\r\n  }\r\n\r\n  const disposedComponentIdsRange = batch.disposedComponentIds();\r\n  const disposedComponentIdsValues = arrayRangeReader.values(disposedComponentIdsRange);\r\n  const disposedComponentIdsLength = arrayRangeReader.count(disposedComponentIdsRange);\r\n  for (let i = 0; i < disposedComponentIdsLength; i++) {\r\n    const componentId = batch.disposedComponentIdsEntry(disposedComponentIdsValues, i);\r\n    browserRenderer.disposeComponent(componentId);\r\n  }\r\n\r\n  const disposedEventHandlerIdsRange = batch.disposedEventHandlerIds();\r\n  const disposedEventHandlerIdsValues = arrayRangeReader.values(disposedEventHandlerIdsRange);\r\n  const disposedEventHandlerIdsLength = arrayRangeReader.count(disposedEventHandlerIdsRange);\r\n  for (let i = 0; i < disposedEventHandlerIdsLength; i++) {\r\n    const eventHandlerId = batch.disposedEventHandlerIdsEntry(disposedEventHandlerIdsValues, i);\r\n    browserRenderer.disposeEventHandler(eventHandlerId);\r\n  }\r\n}\r\n","import { platform } from '../Environment';\r\nimport { MethodHandle, System_String, System_Array } from '../Platform/Platform';\r\nconst httpClientAssembly = 'Microsoft.AspNetCore.Blazor';\r\nconst httpClientNamespace = `${httpClientAssembly}.Http`;\r\nconst httpClientTypeName = 'WebAssemblyHttpMessageHandler';\r\nlet receiveResponseMethod: MethodHandle;\r\nlet allocateArrayMethod: MethodHandle;\r\n\r\n// These are the functions we're making available for invocation from .NET\r\nexport const internalFunctions = {\r\n  sendAsync,\r\n};\r\n\r\nasync function sendAsync(id: number, body: System_Array<any>, jsonFetchArgs: System_String) {\r\n  let response: Response;\r\n  let responseData: ArrayBuffer;\r\n\r\n  const fetchOptions: FetchOptions = JSON.parse(platform.toJavaScriptString(jsonFetchArgs));\r\n  const requestInit: RequestInit = Object.assign(convertToRequestInit(fetchOptions.requestInit), fetchOptions.requestInitOverrides);\r\n\r\n  if (body) {\r\n    requestInit.body = platform.toUint8Array(body);\r\n  }\r\n\r\n  try {\r\n    response = await fetch(fetchOptions.requestUri, requestInit);\r\n    responseData = await response.arrayBuffer();\r\n  } catch (ex) {\r\n    dispatchErrorResponse(id, ex.toString());\r\n    return;\r\n  }\r\n\r\n  dispatchSuccessResponse(id, response, responseData);\r\n}\r\n\r\nfunction convertToRequestInit(blazorRequestInit: BlazorRequestInit) {\r\n  return {\r\n    credentials: blazorRequestInit.credentials,\r\n    method: blazorRequestInit.method,\r\n    headers: blazorRequestInit.headers.map(item => [item.name, item.value])\r\n  };\r\n}\r\n\r\nfunction dispatchSuccessResponse(id: number, response: Response, responseData: ArrayBuffer) {\r\n  const responseDescriptor: ResponseDescriptor = {\r\n    statusCode: response.status,\r\n    statusText: response.statusText,\r\n    headers: [],\r\n  };\r\n  response.headers.forEach((value, name) => {\r\n    responseDescriptor.headers.push({ name: name, value: value });\r\n  });\r\n\r\n  if (!allocateArrayMethod) {\r\n    allocateArrayMethod = platform.findMethod(\r\n      httpClientAssembly,\r\n      httpClientNamespace,\r\n      httpClientTypeName,\r\n      'AllocateArray'\r\n    );\r\n  }\r\n\r\n  // allocate a managed byte[] of the right size\r\n  const dotNetArray = platform.callMethod(allocateArrayMethod, null, [platform.toDotNetString(responseData.byteLength.toString())]) as System_Array<any>;\r\n\r\n  // get an Uint8Array view of it\r\n  const array = platform.toUint8Array(dotNetArray);\r\n\r\n  // copy the responseData to our managed byte[]\r\n  array.set(new Uint8Array(responseData));\r\n\r\n  dispatchResponse(\r\n    id,\r\n    platform.toDotNetString(JSON.stringify(responseDescriptor)),\r\n    dotNetArray,\r\n    /* errorMessage */ null\r\n  );\r\n}\r\n\r\nfunction dispatchErrorResponse(id: number, errorMessage: string) {\r\n  dispatchResponse(\r\n    id,\r\n    /* responseDescriptor */ null,\r\n    /* responseText */ null,\r\n    platform.toDotNetString(errorMessage)\r\n  );\r\n}\r\n\r\nfunction dispatchResponse(id: number, responseDescriptor: System_String | null, responseData: System_Array<any> | null, errorMessage: System_String | null) {\r\n  if (!receiveResponseMethod) {\r\n    receiveResponseMethod = platform.findMethod(\r\n      httpClientAssembly,\r\n      httpClientNamespace,\r\n      httpClientTypeName,\r\n      'ReceiveResponse'\r\n    );\r\n  }\r\n\r\n  platform.callMethod(receiveResponseMethod, null, [\r\n    platform.toDotNetString(id.toString()),\r\n    responseDescriptor,\r\n    responseData,\r\n    errorMessage,\r\n  ]);\r\n}\r\n\r\n// Keep these in sync with the .NET equivalent in WebAssemblyHttpMessageHandler.cs\r\ninterface FetchOptions {\r\n  requestUri: string;\r\n  requestInit: BlazorRequestInit;\r\n  requestInitOverrides: RequestInit;\r\n}\r\n\r\ninterface BlazorRequestInit {\r\n  credentials: string;\r\n  headers: Header[];\r\n  method: string;\r\n}\r\n\r\ninterface ResponseDescriptor {\r\n  // We don't have BodyText in here because if we did, then in the JSON-response case (which\r\n  // is the most common case), we'd be double-encoding it, since the entire ResponseDescriptor\r\n  // also gets JSON encoded. It would work but is twice the amount of string processing.\r\n  statusCode: number;\r\n  statusText: string;\r\n  headers: Header[];\r\n}\r\n\r\ninterface Header {\r\n  name: string;\r\n  value: string;\r\n}\r\n","import '@dotnet/jsinterop';\r\n\r\nlet hasRegisteredNavigationInterception = false;\r\nlet hasRegisteredNavigationEventListeners = false;\r\n\r\n// Will be initialized once someone registers\r\nlet notifyLocationChangedCallback: { assemblyName: string; functionName: string } | null = null;\r\n\r\n// These are the functions we're making available for invocation from .NET\r\nexport const internalFunctions = {\r\n  listenForNavigationEvents,\r\n  enableNavigationInterception,\r\n  navigateTo,\r\n  getBaseURI: () => document.baseURI,\r\n  getLocationHref: () => location.href,\r\n};\r\n\r\nfunction listenForNavigationEvents(assemblyName: string, functionName: string) {\r\n  if (hasRegisteredNavigationEventListeners) {\r\n    return;\r\n  }\r\n\r\n  notifyLocationChangedCallback = { assemblyName, functionName };\r\n\r\n  hasRegisteredNavigationEventListeners = true;\r\n  window.addEventListener('popstate', () => notifyLocationChanged(false));\r\n}\r\n\r\nfunction enableNavigationInterception() {\r\n  if (hasRegisteredNavigationInterception) {\r\n    return;\r\n  }\r\n\r\n  hasRegisteredNavigationInterception = true;\r\n\r\n  document.addEventListener('click', event => {\r\n    if (event.button !== 0 || eventHasSpecialKey(event)) {\r\n      // Don't stop ctrl/meta-click (etc) from opening links in new tabs/windows\r\n      return;\r\n    }\r\n\r\n    // Intercept clicks on all <a> elements where the href is within the <base href> URI space\r\n    // We must explicitly check if it has an 'href' attribute, because if it doesn't, the result might be null or an empty string depending on the browser\r\n    const anchorTarget = findClosestAncestor(event.target as Element | null, 'A') as HTMLAnchorElement;\r\n    const hrefAttributeName = 'href';\r\n    if (anchorTarget && anchorTarget.hasAttribute(hrefAttributeName)) {\r\n      const targetAttributeValue = anchorTarget.getAttribute('target');\r\n      const opensInSameFrame = !targetAttributeValue || targetAttributeValue === '_self';\r\n      if (!opensInSameFrame) {\r\n        return;\r\n      }\r\n\r\n      const href = anchorTarget.getAttribute(hrefAttributeName)!;\r\n      const absoluteHref = toAbsoluteUri(href);\r\n\r\n      if (isWithinBaseUriSpace(absoluteHref)) {\r\n        event.preventDefault();\r\n        performInternalNavigation(absoluteHref, true);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nexport function navigateTo(uri: string, forceLoad: boolean) {\r\n  const absoluteUri = toAbsoluteUri(uri);\r\n\r\n  if (!forceLoad && isWithinBaseUriSpace(absoluteUri)) {\r\n    // It's an internal URL, so do client-side navigation\r\n    performInternalNavigation(absoluteUri, false);\r\n  } else if (forceLoad && location.href === uri) {\r\n    // Force-loading the same URL you're already on requires special handling to avoid\r\n    // triggering browser-specific behavior issues.\r\n    // For details about what this fixes and why, see https://github.com/aspnet/AspNetCore/pull/10839\r\n    const temporaryUri = uri + '?';\r\n    history.replaceState(null, '', temporaryUri);\r\n    location.replace(uri);\r\n  } else {\r\n    // It's either an external URL, or forceLoad is requested, so do a full page load\r\n    location.href = uri;\r\n  }\r\n}\r\n\r\nfunction performInternalNavigation(absoluteInternalHref: string, interceptedLink: boolean) {\r\n  history.pushState(null, /* ignored title */ '', absoluteInternalHref);\r\n  notifyLocationChanged(interceptedLink);\r\n}\r\n\r\nasync function notifyLocationChanged(interceptedLink: boolean) {\r\n  if (notifyLocationChangedCallback) {\r\n    await DotNet.invokeMethodAsync(\r\n      notifyLocationChangedCallback.assemblyName,\r\n      notifyLocationChangedCallback.functionName,\r\n      location.href,\r\n      interceptedLink\r\n    );\r\n  }\r\n}\r\n\r\nlet testAnchor: HTMLAnchorElement;\r\nfunction toAbsoluteUri(relativeUri: string) {\r\n  testAnchor = testAnchor || document.createElement('a');\r\n  testAnchor.href = relativeUri;\r\n  return testAnchor.href;\r\n}\r\n\r\nfunction findClosestAncestor(element: Element | null, tagName: string) {\r\n  return !element\r\n    ? null\r\n    : element.tagName === tagName\r\n      ? element\r\n      : findClosestAncestor(element.parentElement, tagName);\r\n}\r\n\r\nfunction isWithinBaseUriSpace(href: string) {\r\n  const baseUriWithTrailingSlash = toBaseUriWithTrailingSlash(document.baseURI!); // TODO: Might baseURI really be null?\r\n  return href.startsWith(baseUriWithTrailingSlash);\r\n}\r\n\r\nfunction toBaseUriWithTrailingSlash(baseUri: string) {\r\n  return baseUri.substr(0, baseUri.lastIndexOf('/') + 1);\r\n}\r\n\r\nfunction eventHasSpecialKey(event: MouseEvent) {\r\n  return event.ctrlKey || event.shiftKey || event.altKey || event.metaKey;\r\n}\r\n","/* (ignored) */","/* (ignored) */"],"sourceRoot":""}